---
layout: post
tags: [c++]
title: "c++ 虚函数&纯虚函数&可见性"
date: 2023-3-4
author: wsxk
comments: true
---

- [虚函数](#虚函数)
- [纯虚函数](#纯虚函数)
- [可见性](#可见性)


## 虚函数<br>
虚函数是一种c++的机制，它允许一个类的子类能够`重写(override)`父类的函数，实现它自己独特的功能。<br>
下面是一个例子
```c++
#include <iostream>
#include <string>

class Entity
{
public:
	virtual std::string GetName() {
		return "Entity";
	}
	Entity() {

	};
	~Entity() {

	};
private:
};

class Player : public Entity {
private:
	std::string m_name;
public:
	Player(const std::string& name) {
		m_name = name;
	}
	std::string GetName() override{
		return m_name;
	}

};

int main() {
	Entity* e = new Entity;
	std::cout << e->GetName() << std::endl;
	Player* p = new Player("wsxk");
	std::cout << p->GetName() << std::endl;
	Entity* e2 = new Player("test");
	std::cout << e2->GetName() << std::endl;

}
```
可以看出，虚函数还有一个作用就是使得 父类指针指向子类对象时(总是成立，因为子类是父类的超集,所以父类有的方法，子类也都有)可以正确的使用子类方法。<br>


## 纯虚函数<br>
纯虚函数只要声明在这个类中，这个类就无法实例化对象，且强制要求该类子类必须实现纯虚函数的定义。<br>
```c++
#include <iostream>
#include <string>
class Printable {
public:
	virtual std::string GetClassName() = 0;
};

class Entity: public Printable
{
public:
	virtual std::string GetName(){
		return "Entity";
	}
	Entity() {

	};
	~Entity() {

	};
	std::string GetClassName() override{
		return "Entity";
	}
private:
};

class Player : public Entity {
private:
	std::string m_name;
public:
	Player(const std::string& name) {
		m_name = name;
	}
	std::string GetName() override{
		return m_name;
	}
	std::string GetClassName() override{
		return "Player";
	}
};

void PrintClassName(Printable * obj) {
	std::cout << obj->GetClassName() << std::endl;
}

int main() {
	Entity* e = new Entity;
	PrintClassName(e);

	//std::cout << e->GetName() << std::endl;
	Player* p = new Player("wsxk");
	PrintClassName(p);
	//std::cout << p->GetName() << std::endl;
	//Entity* e2 = new Player("test");
	//std::cout << e2->GetName() << std::endl;
}
```

## 可见性<br>
可见性其实指的是`private`,`protected`,`public`<br>
在类中使用的三种可见性对应如下功能:<br>
> 1. private 指类外不能访问，其子类也不能访问，类内的方法可以访问
> 2. protected 指类外不能访问，其子类的方法可以访问，类内的方法可以访问
> 3. public 指类外不能访问，子类不能访问，类内的方法可以访问

protected其实涉及继承问题。
```c++
#include <iostream>

class Entity {
public:
	int x;
	void set(int a, int b, int c) {
		x = a;
		y = b;
		z = c;
	}
protected:
	int y;
private:
	int z;
};

class child : public Entity {
public:
	void set(int a, int b, int c) {
		x = a;
		y = b;
		
	}
};

int main() {
	Entity e;
	e.set(1, 2, 3);
	child c;
	c.x= 2;
}
```
在这里面，在`child`继承`Entity`后，child同样拥有`Entity`中的变量`y和z`，但是`x`消失了（child类中并没有这个变量）<br>