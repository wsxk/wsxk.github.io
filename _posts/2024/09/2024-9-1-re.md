---
layout: post
tags: [re]
title: "reverse engineering: 综述"
date: 2024-9-1
author: wsxk
comments: true
---

- [1. 什么是逆向工程](#1-什么是逆向工程)
- [2. 函数和栈帧](#2-函数和栈帧)
  - [2.1 什么是程序](#21-什么是程序)
  - [2.2 栈帧](#22-栈帧)
  - [2.3 数据](#23-数据)
- [3. 静态分析工具](#3-静态分析工具)
- [4. 动态分析工具](#4-动态分析工具)


## 1. 什么是逆向工程<br>
在讲逆向工程前，先说说正向工程，**正向工程指的是你编写一个程序的过程**，包括确定要写什么程序，开始写程序，编译程序，执行程序<br>
在这个过程中**存在信息损失**<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-3-25/20240819191626.png)
```
在design和code之间，你或许会忘记是谁写的程序

在compile和assemble之间，会丢失代码注释、变量名称、函数名称、结构体数据、有时还会丢失这个算法(optimization)
```
**把正向工程中丢失的信息，通过人的一些努力工作，还原信息，这个过程就叫做逆向工程**<br>
这项技术的核心是:`how do we reverse the design from the binary(我们如何从二进制逆向出设计思想)`<br>

## 2. 函数和栈帧<br>
### 2.1 什么是程序<br>
程序可以按照如下方式进行结构:<br>

- 1. 一个程序(program)由很多个模块(module)组成
- 2. 一个模块(mudole)由很多个函数(functionality)组成
- 3. 一个函数(functionality)包含了很多块(block)
- 4. 块中有很多条指令(instruction)
- 5. 指令(instruction)主要用来操作变量(variables)和数据结构(data structures)


在逆向过程中，`module`通常是以`lib`的形式呈现，即动态库和静态库，开发人员极大程度的依靠库函数。<br>
在逆向时需要关注**库的精细手册，在逆向时把库函数排除在外，专心逆向主要逻辑**<br><br><br>
函数就是指实现好的某种功能，通常每个函数的实现都有明确的目的<br>
例如获取一些数据，分发功能,etc.<br>
**一开始，函数可以单独逆向，之后就可以了解函数们是如何被组合的**<br><br><br>
函数可以通过`graph(图)`表示，`graph`由很多`block(块)`和很多条`edge(边)`构成<br>
`block`就是计算机执行的指令(`instruction`)的集合，block由`edge`连接<br>

### 2.2 栈帧<br>
每个`function`序言和结语的指令都很类似：<br>
**Set up the stack frame.**<br>
**Tear down the stack frame**<br>
开辟栈帧的主要目的是在栈中给每个函数开辟一段空间用于存放局部变量！（但不是必须的）<br>
在一个`elf`文件中，有3个段被用来存放数据:<br>
```
.data: 
used for pre-initialized global writable data (such as global arrays with initial values)

.rodata: 
used for global read-only data (such as string constants)

.bss: 
used for uninitialized global writable data (such as global arrays without initial values)
```
但是这3个段都被用来存放全局变量，对于局部变量，一般都放在栈中，**栈是一段用来存储局部变量和函数调用上下文的空间，采用后进先出的方式(即后向增长)**<br>
顺道一提，程序的环境变量也是存放在栈中的<br>

**gcc编译时，可以通过-fomit-frame-pointer选项取消栈帧的使用**<br>

### 2.3 数据<br>
总结一下，一个程序(program)中用来存放数据的空间有5处:<br>
```
.data: 
used for pre-initialized global writable data (such as global arrays with initial values)

.rodata: 
used for global read-only data (such as string constants)

.bss: 
used for uninitialized global writable data (such as global arrays without initial values)

stack: 
used for statically-allocated local variables

heap: used for dynamically-allocated (malloc()ed) variables. 
```

## 3. 静态分析工具<br>
`Static (as opposed to dynamic) reverse engineering: analyzing a program at rest`<br>
静态分析工具里有很多好用东西:<br>
```
kaitai struct (https://ide.kaitai.io/): file format parser and explorer

nm: lists symbols used/provided by ELF files

strings: dumps ASCII (and other format) strings found in a file

objdump: simple disassembler

checksec (https://github.com/slimm609/checksec.sh): analyzes security features used by an executable
```
当然，上述只能看到二进制文件的某些内容，要想分析程序逻辑，还需要反汇编器！<br>
```
Commercial:
IDA Pro: the "gold standard" of disassemblers (https://www.hex-rays.com/products/ida/)
Binary Ninja: IDA's main commercial competitor (https://binary.ninja/)

Free:
Binary Ninja Cloud: a version of Binary Ninja that runs in your browser! (https://cloud.binary.ninja/) 

Open source:
angr management: an academic binary analysis framework! (https://github.com/angr/angr-management/releases) 
ghidra: a reversing tool created by the National Security Agency (https://ghidra-sre.org/) 
cutter: a reversing tool created by the radare2 open source project (https://cutter.re/) 
```

## 4. 动态分析工具<br>
`Dynamic (as opposed to static) reverse engineering: analyzing a program at runtime.`<br>
动态分析工具就是在程序运行时分析它的逻辑。<br>
常见的动态分析工具有<br>

```
ltrace :traces library calls
strace :traces system calls

Running the program with multiple different inputs might get you farther.
ltrace the program with input A
ltrace the program again with input B
see if you can reverse the algorithm from looking at input and output
still does not scale to complex algorithms
```
前面两个用来分析简单的算法还是没问题的，复杂的就难了，这时候就要请出我们的高手，gdb！<br>

```
gdb: 调试工具！
```

另外还有一个概念叫做`Timeless Debugging`<br>

```
Timeless debugging frees you from having to think of breakpoints ahead of time.

1. record execution
2. rewind execution
3. replay execution
```
相关工具如下:<br>
1. gdb has built-in record-replay functionality 
其网址为[https://sourceware.org/gdb/current/onlinedocs/gdb/Process-Record-and-Replay.html](https://sourceware.org/gdb/current/onlinedocs/gdb/Process-Record-and-Replay.html)
2. rr is a highly-performant record-replay engine 
[https://github.com/mozilla/rr](https://github.com/mozilla/rr) <br>
3. qira is a timeless debugger made for reverse engineering 
[https://qira.me/](https://qira.me/)