---
layout: post
tags: [re]
title: "reverse engineering: 综述"
date: 2024-9-1
author: wsxk
comments: true
---

## 1. 什么是逆向工程<br>
在讲逆向工程前，先说说正向工程，**正向工程指的是你编写一个程序的过程**，包括确定要写什么程序，开始写程序，编译程序，执行程序<br>
在这个过程中**存在信息损失**<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-3-25/20240819191626.png)
```
在design和code之间，你或许会忘记是谁写的程序

在compile和assemble之间，会丢失代码注释、变量名称、函数名称、结构体数据、有时还会丢失这个算法(optimization)
```
**把正向工程中丢失的信息，通过人的一些努力工作，还原信息，这个过程就叫做逆向工程**<br>
这项技术的核心是:`how do we reverse the design from the binary(我们如何从二进制逆向出设计思想)`<br>

## 2. 函数和栈帧<br>
### 2.1 什么是程序<br>
- 1. 一个程序(program)由很多个模块(module)组成
- 2. 一个模块(mudole)由很多个函数(functionality)组成
- 3. 一个函数(functionality)包含了很多块(block)
- 4. 块中有很多条指令(instruction)
- 5. 指令(instruction)主要用来操作变量(variables)和数据结构(data structures)


在逆向过程中，`module`通常是以`lib`的形式呈现，即动态库和静态库，开发人员极大程度的依靠库函数。<br>
在逆向时需要关注**库的精细手册，在逆向时把库函数排除在外，专心逆向主要逻辑**<br><br><br>
函数就是指实现好的某种功能，通常每个函数的实现都有明确的目的<br>
例如获取一些数据，分发功能,etc.<br>
**一开始，函数可以单独逆向，之后就可以了解函数们是如何被组合的**<br><br><br>
函数可以通过`graph(图)`表示，`graph`由很多`block(块)`和很多条`edge(边)`构成<br>
`block`就是计算机执行的指令(`instruction`)的集合，block由`edge`连接<br>

### 2.2 栈帧<br>
每个`function`序言和结语的指令都很类似：<br>
**Set up the stack frame.**<br>
**Tear down the stack frame**<br>
开辟栈帧的主要目的是在栈中给每个函数开辟一段空间用于存放局部变量！（但不是必须的）<br>
在一个`elf`文件中，有3个段被用来存放数据:<br>
```
.data: 
used for pre-initialized global writable data (such as global arrays with initial values)

.rodata: 
used for global read-only data (such as string constants)

.bss: 
used for uninitialized global writable data (such as global arrays without initial values)
```
但是这3个段都被用来存放全局变量，对于局部变量，一般都放在栈中，**栈是一段用来存储局部变量和函数调用上下文的空间，采用后进先出的方式(即后向增长)**<br>
顺道一提，程序的环境变量也是存放在栈中的<br>

**gcc编译时，可以通过-fomit-frame-pointer选项取消栈帧的使用**<br>

### 2.3 数据<br>
总结一下，一个程序(program)中用来存放数据的空间有5处:<br>
```
.data: 
used for pre-initialized global writable data (such as global arrays with initial values)

.rodata: 
used for global read-only data (such as string constants)

.bss: 
used for uninitialized global writable data (such as global arrays without initial values)

stack: 
used for statically-allocated local variables

heap: used for dynamically-allocated (malloc()ed) variables. 
```
