---
layout: post
tags: [pwn]
title: "Exploitation Scenarios"
date: 2024-10-1
author: wsxk
comments: true
---

- [1. introduction](#1-introduction)
- [2. Exploitation Scenarios](#2-exploitation-scenarios)
	- [2.1 Control Flow Hijack to Shellcode](#21-control-flow-hijack-to-shellcode)
	- [2.2 Vulnerability Side-Effects](#22-vulnerability-side-effects)
		- [2.2.1 seccomp](#221-seccomp)
	- [2.3 JIT Spraying](#23-jit-spraying)


## 1. introduction<br>
ä¹‹å‰è®²äº†é‚£ä¹ˆå¤šé—®é¢˜ï¼ŒåŒ…æ‹¬`shellcode`å’Œ`memory errors`ï¼Œç°åœ¨ç»ˆäºåˆ°äº†è®²**åˆ©ç”¨åœºæ™¯(shellcode + memory errorsç»“åˆ)**çš„æ—¶å€™äº†ï¼<br>
æ‰€è°“**åˆ©ç”¨åœºæ™¯ï¼Œå°±æ˜¯æ€è€ƒç›®æ ‡å“ªä¸ªä½ç½®ä¼šæœ‰æ¼æ´ï¼Œå¦‚æœæœ‰äº†æ¼æ´ï¼ˆæ ˆæº¢å‡ºï¼Œetcï¼‰ï¼Œä½ å¦‚ä½•åˆ©ç”¨è¿™ä¸ªæ¼æ´æ¥å®ç°æ”»å‡»ï¼ˆç ´åç›®æ ‡ï¼Œæ³„éœ²ä¿¡æ¯ï¼Œå¤ºå–æ§åˆ¶æƒï¼Œetcï¼‰**<br>
å…ˆä»é«˜æ‰‹`Phineas Fisher`çš„äº‹è¿¹å¼€å§‹è¯´èµ·ï¼Œè¿™ä½å“¥ä»¬åœ¨2016å¹´é»‘äº†`Hacking Teamï¼ˆæ˜¯ä¸€å®¶å¸®åŠ©æ”¿åºœé’ˆå¯¹æ–°é—»è®°è€…ï¼Œæ¿€è¿›åˆ†å­ï¼Œæ”¿åºœä¸­çš„åå¯¹æ´¾ä»¥åŠå…¶ä»–çš„å¯¹æ”¿åºœå¯èƒ½é€ æˆçš„å¨èƒå› ç´ è¿›è¡Œå…¥ä¾µå’Œç›‘æ§çš„å…¬å¸ï¼‰`ï¼Œå¹¶è®²è§£äº†ä»–æ˜¯å¦‚ä½•å…¥ä¾µçš„ã€‚<br>
ä»ä»–çš„å…¥ä¾µè¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å­¦ä¹ åˆ°åˆ©ç”¨åœºæ™¯çš„æ€è·¯ã€‚<br>
```
1. External reconnaissance. å¤–éƒ¨ä¾¦å¯Ÿï¼Œå³è§‚å¯Ÿç›®æ ‡çš„è¿è¡Œé€»è¾‘
Look at the program. Understand it. How does it work? What might be potential vulnerable functionality?

2. Gaining a foothold. ç«™ç¨³è„šè·Ÿï¼Œå³æŒ–ç›®æ ‡çš„æ´
Find the teenies tiniest security hole. Exploit it!

3. Internal reconnaissance. å†…éƒ¨ä¾¦å¯Ÿï¼Œå³æ€è€ƒæŒ–çš„æ´æœ‰ä»€ä¹ˆç”¨
What does your vulnerability change in the program state? What else does this allow you to do?

4. Gaining influence. è·å¾—å½±å“ï¼ˆæŒ‡åˆ©ç”¨æ¼æ´è·å¾—æ›´å¤šçš„ç›®æ ‡ä¿¡æ¯ï¼‰
Exploit the security hole(s) ,your initial corruption opened up.

5. Total compromise. å®Œå…¨æ§åˆ¶ï¼Œä¸€æ­¥ä¸€æ­¥å®Œå…¨æ§åˆ¶ç›®æ ‡ï¼
Repeat steps 3 and 4 until the system is totally broken.

6. Gloating. ç¬‘ğŸ˜€
Get and submit the flag!
```
è¿™ä¹Ÿæ˜¯ç°åœ¨æ™®éçš„æ¸—é€æµ‹è¯•æ€è·¯ï¼<br>

## 2. Exploitation Scenarios<br>
ç°åœ¨å…·ä½“è¯´è¯´æœ‰å“ªäº›åˆ©ç”¨åœºæ™¯â‘§<br>

### 2.1 Control Flow Hijack to Shellcode<br>
ç¬¬ä¸€ä¸ªå°±æ˜¯`æ§åˆ¶æµå¤¹æŒåˆ°shellcode`<br>
å‚è€ƒä¾‹å­:<br>
```c
void bye1() { puts("Goodbye!"); }
void bye2() { puts("Farewell!"); }
void hello(char *name, void (*bye_func)())
{
	printf("Hello %s!\n", name);
	bye_func();
}
int main(int argc, char **argv)
{
	char name[1024];
	gets(name);
	srand(time(0));
	if (rand() % 2) hello(name, bye1);
	else hello(name, bye2);
}
```
è¯¥ä¾‹å­ä¸­ï¼Œå› ä¸ºæœ‰`memory errors`é—®é¢˜ï¼Œå¯¼è‡´æˆ‘ä»¬å¯ä»¥åœ¨æ ˆä¸­å†™å…¥`shellcode`ï¼Œå¦‚æœæˆ‘ä»¬çŸ¥é“`æ ˆåœ°å€`ï¼Œå°±èƒ½å®ç°åˆ©ç”¨ï¼<br>
è¯¸å¦‚å„ç§æ ˆä¿æŠ¤ï¼Œç ´è§£æ–¹æ³•ä¸[https://wsxk.github.io/memoryerror/](https://wsxk.github.io/memoryerror/)ç±»ä¼¼ï¼Œè¿™é‡Œä¸è¿‡å¤šè§£é‡Š<br>

### 2.2 Vulnerability Side-Effects<br>
`A vulnerability in a program generally has more effects than just hijacking control flow.`<br>
å‚è€ƒä¾‹å­:<br>
```c
#include <seccomp.h>
#include <assert.h>
int main(int argc, char **argv) {
	struct {
char shellcode[128];
int sandboxed;
} program;
	program.sandboxed = 1;
	gets(program.shellcode);
	
if (program.sandboxed) {
	scmp_filter_ctx ctx;
	ctx = seccomp_init(SCMP_ACT_KILL);
		assert(seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0) == 0);
		assert(seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0) == 0);
	assert(seccomp_load(ctx) == 0);
	}
((void(*)())program.shellcode)();
}
```
è¯¥åœºæ™¯ä¸­ï¼Œå¯ä»¥é€šè¿‡`memory errors`æ¼æ´æ¥å†™å…¥`shellcode`ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥ä¿®æ”¹ç¨‹åºçš„æ²™ç®±ä¿æŠ¤ï¼<br>
å†æ¥çœ‹ä¸€ä¸ªä¾‹å­:<br>
```c
int main(int argc, char **argv) {
	struct {
char shellcode[128];
char *shellcode_copy;
} program;
data.shellcode_copy = malloc(128);
	gets(data.shellcode);
	strcpy(data.shellcode_copy, data.shellcode);
}
```
è¿™ä¸ªåœºæ™¯ä¸­ï¼Œå¦‚æœæº¢å‡ºå¯¼è‡´`shellcode_copy`è¢«ä¿®æ”¹ï¼Œé‚£ä¹ˆè¯¥ç¨‹åºä¼šåœ¨`main`è¿”å›å‰å°±å´©æºƒï¼<br>

#### 2.2.1 seccomp<br>
`seccomp`æ˜¯linuxå†…æ ¸æä¾›çš„ä¸€ä¸ªå®‰å…¨æœºåˆ¶ï¼Œå…è®¸è¿›ç¨‹è‡ªå·±é™åˆ¶ å“ªäº›ç³»ç»Ÿè°ƒç”¨å¯ä»¥è¢«æ‰§è¡Œ<br>
æ ¸å¿ƒçš„å‡½æ•°å¦‚ä¸‹:<br>
```c
ctx=seccomp_init();//åˆ›å»ºscmp_filter_ctxè¿‡æ»¤å™¨å¯¹è±¡
//å‚æ•°å¯ä»¥æ˜¯ SCMP_ACT_KILL(0)ï¼ˆå¯¹äºæœªå…è®¸çš„ç³»ç»Ÿè°ƒç”¨ï¼Œç»ˆæ­¢è¿›ç¨‹ ç™½åå•ï¼‰ æˆ– SCMP_ACT_ALLOW(0x7fff0000 å¯¹äºæœªå…è®¸çš„ç³»ç»Ÿè°ƒç”¨ï¼Œå…è®¸æ‰§è¡Œï¼Œé»‘åå•)
seccomp_rule_add(ctx,0x7FFF0000,syscall_num,0);// æ·»åŠ è§„åˆ™ï¼Œè¿™é‡Œè¡¨ç¤ºå…è®¸syscall_numçš„è°ƒç”¨ï¼Œ0è¡¨ç¤ºä¸å¯¹ç³»ç»Ÿè°ƒç”¨çš„å‚æ•°åšé™åˆ¶

seccomp_load(ctx);//å°†è§„åˆ™åŠ è½½åˆ°å†…æ ¸ï¼Œä½¿å…¶ç”Ÿæ•ˆ
```
å¦‚æœç¨‹åºæœ‰å†…å­˜é”™è¯¯å…è®¸ä½ æ§åˆ¶ç¨‹åºä¸æ‰§è¡Œseccompï¼Œå°±å¯ä»¥ç»•è¿‡è¿™ä¸ªé™åˆ¶ï¼<br>
**å¦‚æœåªå…è®¸ä½ ä½¿ç”¨2ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œé¦–é€‰chmodï¼Œä»»æ„ä¸€ä¸ªçœ‹èƒ½å¦è®©ç¨‹åºé¡ºåˆ©æ‰§è¡Œ**<br>
é¡ºä¾¿ç»™å‡ºæ‰§è¡Œ`chmod`çš„æ±‡ç¼–<br>
```python
"""    /* push b'/flag\x00' */
    mov rax, 0x101010101010101
    push rax
    mov rax, 0x101010101010101 ^ 0x67616c662f
    xor [rsp], rax
    /* call open('rsp', , 'rdx') */
    push SYS_chmod /* 90 */
    pop rax
    mov rdi, rsp
    mov rsi,  511/* 0777 */
    syscall
"""
```


### 2.3 JIT Spraying<br>
`JIT Spraying`å¯ä»¥ç”¨æ¥ç»•è¿‡`DEPå’ŒASLR(æ¦‚ç‡)`ä¿æŠ¤ã€‚<br>
```
Modern higher-level languages (JavaScript, Java, Lua, Python, etc) 
utilize Just in Time Compilation.

1. Code is written in JavaScript.
2. At runtime, necessary code is compiled to binary code.
3. Binary code executes very fast.

Of course, this means that an attacker that can inject
higher-level code can influence the resulting native code...

... including immediate values stored!
```
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-9-25/20241001102248.png)
å¯¹äº`alsr`ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªå®Œå…¨çš„è§£å†³æ–¹æ¡ˆï¼Œä½†æ˜¯å¯ä»¥éƒ¨åˆ†è§£å†³!<br>
**æ ¸å¿ƒæ€è·¯æ˜¯åœ¨å¾ˆå¤šé¡µéƒ½å†™å…¥ä½ æƒ³æ‰§è¡Œçš„ä»£ç ï¼è¿™æ ·çˆ†ç ´çš„æ¦‚ç‡å°±å¤§å¤§æé«˜äº†**<br>