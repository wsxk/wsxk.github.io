---
layout: post
tags: [Android]
title: "smali语言"
author: wsxk
date: 2024-3-20
comments: true
---

- [前言](#前言)
- [0. java的重要机制](#0-java的重要机制)
- [1. smali语言](#1-smali语言)


## 前言<br>
希望看这篇前先去看看[https://wsxk.github.io/android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/](https://wsxk.github.io/android%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/)<br>
这是我2年前初学`android`时总结的文章，感觉还是能让你对`android`有一个基本的概念<br>
最近做`android`题略感力不从心，或许是之前基础没学好，导致逆向看代码比较痛苦的缘故（anyway，`java`都没学好呢，hhh<br>
现在就从在之前写过的文章的基础上再往前精进<br>

## 0. java的重要机制<br>
`建议先学习一下java的基本语法和概念，虽然不学无所谓，但是还是建议学一下，方便你之后了解什么是smali`<br>
`另外java的一些奇特的机制，比如反射，还是有必要了解的，不然android逆向会有障碍`<br>
当然，描述一些常见的字符运算就没有必要了，这里直接说一些java的比较重要的特性<br>
**0.1 首先说比较重要的一点，java中的`char`类型，也是占用2个字节，java在内存中总是使用Unicode编码**<br>
所以即使是`char a = 'A';`,在内存中的表示也为`\x0041`，也正因如此，`char a = '中';`这样的语句也是合法的<br><br>
另一个我关注的点是`java`当中的`反射`机制<br>
**0.2 反射:Java的反射是指程序在运行期可以拿到一个对象的所有信息。**<br>
```
1. JVM为每个加载的class及interface创建了对应的Class实例来保存class及interface的所有信息；
注意，这里的Class是一种名叫Class的class
```
虽然很绕，但是其定义如下：<br>
```java
public final class Class {
    private Class() {} //值得一提的是 因为定义为private，所以只有JVM有权调用这个函数
}
```

```
2. 获取一个class对应的Class实例后，就可以获取该class的所有信息；
这是因为JVM在运行中如果需要用到某个类型A，就会将保存A类型信息的文件A.class加载到JVM中，并创建一个Class实例来保存A类型的所有信息。
包括类名、包名、父类、实现的接口、所有方法、字段等
```
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2023-12-30/20240324143519.png)
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2023-12-30/20240324144557.png)

```
3. 通过Class实例获取class信息的方法称为反射（Reflection）；
```
具体而言，通过`Class实例获取class信息的方法有三种`<br>
```java
package java_code;
public class Main {
    public static void main(String[] args){
        try {
            String  a = "wsxk";
            Class cls1 = a.getClass(); // 方法一
            Class cls2 = String.class; // 方法二
            Class cls3 = Class.forName("java.lang.String"); // 方法三
            printClassInfo(Class.class);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
    
    static void printClassInfo(Class cls) {
        System.out.println("Class name: " + cls.getName());
        System.out.println("Simple name: " + cls.getSimpleName());
        if (cls.getPackage() != null) {
            System.out.println("Package name: " + cls.getPackage().getName());
        }
        System.out.println("is interface: " + cls.isInterface());
        System.out.println("is enum: " + cls.isEnum());
        System.out.println("is array: " + cls.isArray());
        System.out.println("is primitive: " + cls.isPrimitive());
    }
}

```

```
4. JVM总是动态加载class，可以在运行期根据条件来控制加载class
```

`反射机制`的出现，很大程度是服务于**java底层机制或底层api的**，比如某个函数func是用来迭代数组里的元素的，然而数组里的元素的类型是可以是int，float.....，然而根据类型来将func写成funcA，funcB，...又费事，这时就可以通过获取该类型的Class，调用其提供的方法来进行迭代了<br>
对于反射的使用，想要有更多了解，可以看看[https://www.liaoxuefeng.com/wiki/1252599548343744/1255945147512512](https://www.liaoxuefeng.com/wiki/1252599548343744/1255945147512512)<br>

## 1. smali语言<br>


