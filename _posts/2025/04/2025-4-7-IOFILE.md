---
layout: post
tags: [pwn]
title: "File Struct"
author: wsxk
date: 2025-4-7
comments: true
---

- [1. 什么是File Descriptor](#1-什么是file-descriptor)
  - [1.1 open,read,write](#11-openreadwrite)
  - [1.2 fopen,fread,fwrite](#12-fopenfreadfwrite)
- [2. 什么是File Struct](#2-什么是file-struct)
  - [2.1 Reading from File to Memory](#21-reading-from-file-to-memory)
  - [2.2 Writing from Memory to File](#22-writing-from-memory-to-file)
  - [2.3 File Struct详细分析](#23-file-struct详细分析)
    - [2.3.1 \_flags](#231-_flags)
    - [2.3.2 Buffer Pointers](#232-buffer-pointers)
    - [2.3.3 \_fileno](#233-_fileno)


# 1. 什么是File Descriptor<br>
通常情况下,`file descriptor`指的是通过`open`函数打开一个文件后返回的内容:<br>
```c
int fd = open(“/home/wsxk/test.txt”, O_RDWR)
printf(“%d\n”, fd)
```
**可以看出file descriptor实际上是一种整型数据，它是一个索引值**<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2025-3-25/20250403192116.png)
每个进程，在内核空间中都会维护一个`process file table`；`file descriptor`返回的值就代表的是`process file table`的索引，其中存放的值 是指向`Global File Table`的指针; `Global File Table`存放的是文件在kernel中的描述结构。<br>
而以这种形式进行文件操作，**每次操作时均要陷入内核态，进行进程上下文切换；导致在进行read/write操作时，需要花费更大的开销**<br>
`libc`提供了另一套文件操作机制`fopen,fread,fwrite`，能够更快的处理这个文件操作，它是如何实现的呢？<br>
## 1.1 open,read,write<br>
给定一个例子：<br>
```c
#include <stdio.h>
#include <sys/fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
int main(){
    char buf[0x1000];
    int fd = open("/dev/urandom",O_RDONLY);
    for(int i=0;i<50000;i++){
        read(fd,buf,0x20);
    }
    return 0;
}
```
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2025-9-25/20250407112340.png)
```
strace ./read_loop 2>&1 | grep -E "^read" | wc -l
# strace ./readloop 跟踪read_loop运行的系统调用
# 2>&1 starce的输出在标准错误上，需要重定向到标准输出才能做后续的grep等操作
# | grep -E "^read" 使用扩展正则表达式，检索以read开头的行
# | wc -l 统计出现行数
```
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2025-9-25/20250407112748.png)

## 1.2 fopen,fread,fwrite<br>
```c
#include <stdio.h>
#include <sys/fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
int main(){
    char buf[0x1000];
    FILE * file = fopen("/dev/urandom","r");
    for(int i=0;i<50000;i++){
        fread(buf,1,0x20,file);
    }
    return 0;
}
```
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2025-9-25/20250407112436.png)
高下立判。<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2025-9-25/20250407113009.png)
可以看出，fread函数的使用明显降低了系统调用的次数，从而使速度大大提高。<br>

# 2. 什么是File Struct<br>
libc中的fread系列函数，使用了`file struct`，而不是`file descriptor`。**`file struct`中包含了read/write使用的buffer指针，从而减少了上下文切换的次数，提高了I/O的性能**<br>
`file struct`的定义在[https://elixir.bootlin.com/glibc/glibc-2.31/source/libio/bits/types/struct_FILE.h#L49](https://elixir.bootlin.com/glibc/glibc-2.31/source/libio/bits/types/struct_FILE.h#L49)中<br>
***值得一提的是，file struct的结构及其buffer都位于用户态当中，这也是后续利用的基础条件之一***<br>
```c
/* The tag name of this struct is _IO_FILE to preserve historic
   C++ mangled names for functions taking FILE* arguments.
   That name should not be used in new code.  */
struct _IO_FILE
{
  int _flags;		/* High-order word is _IO_MAGIC; rest is flags. */

  /* The following pointers correspond to the C++ streambuf protocol. */
  char *_IO_read_ptr;	/* Current read pointer */
  char *_IO_read_end;	/* End of get area. */
  char *_IO_read_base;	/* Start of putback+get area. */
  char *_IO_write_base;	/* Start of put area. */
  char *_IO_write_ptr;	/* Current put pointer. */
  char *_IO_write_end;	/* End of put area. */
  char *_IO_buf_base;	/* Start of reserve area. */
  char *_IO_buf_end;	/* End of reserve area. */

  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset; /* This used to be _offset but it's too small.  */

  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
};

struct _IO_FILE_complete
{
  struct _IO_FILE _file;
#endif
  __off64_t _offset;
  /* Wide character stream stuff.  */
  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;
  /* Make sure we don't get into trouble again.  */
  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
```
## 2.1 Reading from File to Memory<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2025-9-25/20250407115120.png)
当从文件读取内容时，实际上是从buffer中读取内容的，如下图所示:<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2025-9-25/20250407115707.png)
如果当前buffer的内容已经被读取完毕，`_IO_read_ptr会重置成_IO_read_base`，并调用系统调用从文件中重新读取内容填充到buffer中。<br>
如果一个文件内容没有那么长，实际上如下图所示:<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2025-9-25/20250407115832.png)

## 2.2 Writing from Memory to File<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2025-9-25/20250407115428.png)
当把内容写入文件中时，实际上是写入到buffer中，如下图所示:<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2025-9-25/20250407120322.png)
当buffer已被填充完毕后,`_IO_write_prt会重置成_IO_write_base`，并调用系统调用把buffer的内容写入到文件中。<br>

## 2.3 File Struct详细分析<br>
### 2.3.1 _flags<br>
其定义在[https://elixir.bootlin.com/glibc/glibc-2.31/source/libio/libio.h#L62](https://elixir.bootlin.com/glibc/glibc-2.31/source/libio/libio.h#L62)有注明<br>
```c
int _flags;		/* High-order word is _IO_MAGIC; rest is flags. */
//字面意思，高2字节代表file struct结构
#define _IO_MAGIC         0xFBAD0000 /* Magic number */ 
//低2字节就表示某些标识
#define _IO_UNBUFFERED        0x0002 //有这个标志就表示关闭buffer功能，本质上和open/read/write一样
#define _IO_NO_READS          0x0004 /* Reading not allowed.  */
#define _IO_NO_WRITES         0x0008 /* Writing not allowed.  */
#define _IO_CURRENTLY_PUTTING 0x0800
#define _IO_IS_APPENDING      0x1000
```
### 2.3.2 Buffer Pointers<br>
无需多言<br>
```c
/* The following pointers correspond to the C++ streambuf protocol. */
char *_IO_read_ptr;	/* Current read pointer */
char *_IO_read_end;	/* End of get area. */
char *_IO_read_base;	/* Start of putback+get area. */
char *_IO_write_base;	/* Start of put area. */
char *_IO_write_ptr;	/* Current put pointer. */
char *_IO_write_end;	/* End of put area. */
char *_IO_buf_base;	/* Start of reserve area. */
char *_IO_buf_end;	/* End of reserve area. */
```

### 2.3.3 _fileno<br>
实际上就是这个文件的`file descriptor`<br>
```c
int _fileno;
```


<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-C22S5YSYL7"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-C22S5YSYL7');
</script>