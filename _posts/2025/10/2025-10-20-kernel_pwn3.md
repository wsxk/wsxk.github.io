---
layout: post
tags: [kernel_pwn]
title: "kernel security 3: 利用内核漏洞操纵其他进程"
author: wsxk
date: 2025-10-20
comments: true
---

- [1. 前言](#1-前言)
- [2. 子进程存储flag](#2-子进程存储flag)
  - [2.1 解题思路](#21-解题思路)


# 1. 前言<br>
遇到了某种特定类型的CTF题目，大意是说，我们只能和父进程交互，但是flag被保留在子进程的内存当中（没有其他地方留存），父进程能够与内核驱动交互。题目的本意是让我们通过驱动的漏洞，让父进程能够偷取子进程的信息，打破进程隔离。<br>
我感觉十分的牛逼，故单开一章用于讲述实际实现和解法。<br>

# 2. 子进程存储flag<br>
代码逻辑如下图所示:<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2025-9-25/20251008123352.png)
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2025-9-25/20251008123312.png)
总的来说，父进程创建子进程读取flag文件的内容后，并删除flag文件本身。
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2025-9-25/20251008133555.png)
随后父进程开启seccomp，只允许write执行，并允许我们输入shellcode<br>
有问题的驱动程序代码如下:<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2025-9-25/20251008133635.png)

## 2.1 解题思路<br>



<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-C22S5YSYL7"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-C22S5YSYL7');
</script>