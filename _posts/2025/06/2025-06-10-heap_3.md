---
layout: post
tags: [pwn]
title: "glibc 2.35 malloc/free全流程"
author: wsxk
date: 2025-6-10
comments: true
---

- [0. 回顾： tcache](#0-回顾-tcache)
- [1. glibc 2.35： malloc/free](#1-glibc-235-mallocfree)
  - [1.1 free](#11-free)
  - [1.2 malloc](#12-malloc)
  - [1.3 tcachebin之外的chunk metadata](#13-tcachebin之外的chunk-metadata)
  - [1.4 double list](#14-double-list)

PS：之前的利用基本都集中在`tcache`中，但是libc的堆管理远不止`tcache`，现在我们来看看`libc`中堆管理到底会怎么分配内存<br>

# 0. 回顾： tcache<br>
到目前为止，我们学习过的tcache，有四个明显的特性:<br>
```
1. Bins of constant size up to 1032 bytes
2. Caches up to seven freed chunks
3. Singly linked list
4. Safe-Linking
```
tcache被free时，其元数据如下所示:<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2025-9-25/20250602110814.png)
其中**size的前3位，分别为A(标志chunk是否是main_arena以外的arena分配)，M(标志chunk是否是mmap出来的)，P(prev_inuse为，标志前一个chunk是否被使用，1都是已经被使用)**<br>
下图为一个tcachebin的结构:<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2025-9-25/20250602110958.png)

# 1. glibc 2.35： malloc/free<br>
## 1.1 free<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2025-9-25/20250602110444.png)
其实可以分析一下具体流程：<br>
```
1. 如果chunk能放入tcachebin，就会放入tcachebin中；如果不能放入tcachebin，进入第二步
2. 如果chunk能放入fastbin，就会放入fastbin中；如果不能放入fastbin，进入第三步
3. 判断该chunk是不是mmap出来的，如果是，调用munmap进行回收；如果不是，进入第四步
4. 该chunk是不是大于65kb，如果是，clear并consolidate fastbin中的chunk，并进入第五步；如果不是，直接进入第五步
5. 该chunk放入unsortedbin中。
```
**第四步提到的clear并consolidate fastbin中的chunk,这个步骤其实相当重要，我们之后会再提到**<br>


## 1.2 malloc<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2025-9-25/20250602181018.png)
```
1. 从tcache中找符号大小的chunk，如果找到，从tcache中取出，并返回；如果没有符号的chunk，进入第二步
2. 从fastbin中找符合大小的chunk，如果找到，从fastbin中取出，并返回；如果找不到，进入第三步
3. 从smallbin中找符合大小的chunk，如果找到，从smallbin中取出，并返回；如果找不到，进入第四步
4. consollidate fastbins，从unsortedbin中找符合大小的chunk，如果找到，从unsortedbin中取出，并返回；如果找不到，进入第五步。注意在遍历unsortedbin的过程中如果trunk不符合大小，我们会把它归类到smallbin/largebin中
5. 从largebin中找符合大小的chunk，如果找到，从largebin中取出，并返回；如果找不到，进入第六步。
6. 判断申请的大小，如果很大，使用mmap申请内存并返回；如果不是，进入第七步。
7. 从wilderness中切割chunk并返回。
```

## 1.3 tcachebin之外的chunk metadata<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2025-9-25/20250603203005.png)

## 1.4 double list<br>
fastbin和tcachebin都是单向链表，然而，smallbin、unsortedbin、largebin是双向链表，其结构大致可以如下所示:<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2025-9-25/20250603203257.png)
为什么要整一个双向链表呢？因为双向链表在拆除其中一个chunk的时候非常方便。<br>
对于单向链表而言，除非是摘靠前的trunk，那么摘是比较容易的,但是如果摘得trunk比较靠后，那就很麻烦了，需要大量的性能开销.<br>
双向链表就不会，双向链表中的trunk在做摘除时，不需要遍历整个链表。<br>
glibc中涉及这种频繁的摘除操作的步骤叫做`consolidation`（已经提到过了）<br>


<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-C22S5YSYL7"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-C22S5YSYL7');
</script>