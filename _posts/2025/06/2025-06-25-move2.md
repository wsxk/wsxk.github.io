---
layout: post
tags: [blockchain]
title: "move 漏洞类型"
author: wsxk
date: 2025-6-25
comments: true
---


- [1. Move语言常见漏洞](#1-move语言常见漏洞)
  - [1.1 未验证输入](#11-未验证输入)
  - [1.2 逻辑错误](#12-逻辑错误)
  - [1.3 权限控制不足](#13-权限控制不足)
  - [1.4 整数溢出/下溢](#14-整数溢出下溢)
  - [1.5 资源管理不当](#15-资源管理不当)
- [2. 泛型类型安全](#2-泛型类型安全)


# 1. Move语言常见漏洞<br>
## 1.1 未验证输入<br>
有些输入，在使用前未经过验证，比如允许你设置为`2^64-1`，那么将导致匪夷所思的问题：<br>
```
public entry fun check_access(score: u64) {
    if (score+1 > 50) { 
        return false;
    }else {
        return true;
    }
}
```
虽然例子有些离谱，但是确实是这样的。<br>

## 1.2 逻辑错误<br>
有的开发者在开发时，会遗漏临界条件，如：
```
public struct AccessControl has key {
    id: UID,
    is_allowed: bool,
    threshold: u64
}

public entry fun check_access(access: &mut AccessControl, score: u64) {
    if (score > 50) { // 应为 >= 50，但是设置为 >50
        access.is_allowed = true;
    }
}
```
当然更复杂的比如逻辑写反了等等，也是比较常见的。<br.>

## 1.3 权限控制不足<br>
函数未限制调用者身份，允许任何人执行敏感操作。<br>
```
Move 的 public entry fun 默认对所有地址开放，需手动验证 tx_context::sender.
Sui 的共享对象尤其需注意权限。
比如：
public entry fun reset_counter(counter: &mut Counter) { // 未验证调用者
  counter.count = 0; 
}
```
导致任何人都可以重置计数器。<br>

## 1.4 整数溢出/下溢<br>
在 Sui 中，Move 的整数运算（如 u64 的加法、减法）默认启用溢出检查，溢出或下溢会导致交易失败.<br>
```
module counter::counter{
    use sui::event;

    public struct Counter has key {
        id: UID,
        count: u64,
    }

    public struct CounterEmit has copy, drop{
        count: u64,
    }

    fun init(ctx: &mut TxContext){
        transfer::share_object(Counter { id:object::new(ctx), count: 0 });
    }

    public entry fun add(counter: &mut Counter,amount: u64){
        counter.count = counter.count + amount;
        event::emit(CounterEmit { count: counter.count })
    }

    public entry fun reduce(counter: &mut Counter,amount: u64){
        counter.count = counter.count - amount;
        event::emit(CounterEmit { count: counter.count })
    }
}
```

## 1.5 资源管理不当<br>
资源未正确转移或销毁，导致编译错误。<br>
这个属于编译错误，对安全性的影响倒不大。(对开发影响很大，非常影响体验)<br>

# 2. 泛型类型安全<br>
在`Sui Move`中，泛型类型是由调用者在运行时提供的`用户输入`。如果合约未验证泛型类型`<T>`是否符合预期，攻击者可以传入任意类型,导致难以预想的问题。<br>
一个典型的具有泛型参数的函数的例子如下:<br>
```
public entry fun register_voter<T>(vote_coin: coin::Coin<T>, ctx: &mut TxContext) {
    let amount = vote_coin.value();
    assert!(amount == 100,1);
    let sender = tx_context::sender(ctx);
    let token = VoteToken<T> {
        id: object::new(ctx),
        amount: 100,
    };
    public_transfer(token, sender);
    public_transfer(vote_coin, @0x0);
}
```
其中T是我们可控的参数，如果不进行限制，将导致:<br>
```
伪造凭证：攻击者创建非法类型的对象（如 VoteToken<FakeToken>）绕过权限检查。
逻辑破坏：非预期类型导致合约状态异常，影响核心功能（如投票结果错误）。
资源滥用：攻击者利用伪造类型创建无效资源，干扰合约运行或耗尽 Gas.
```

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-C22S5YSYL7"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-C22S5YSYL7');
</script>