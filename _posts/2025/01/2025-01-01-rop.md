---
layout: post
tags: [pwn]
title: "ROP"
author: wsxk
date: 2025-1-1
comments: true
---

- [0. ROP的起源](#0-rop的起源)
  - [0.1 shellcode的限制： No-execute bit](#01-shellcode的限制-no-execute-bit)
  - [0.2 思想起源： Return-to-libc](#02-思想起源-return-to-libc)
  - [0.3 x86-\>x64时代的变迁](#03-x86-x64时代的变迁)

终于到了最怀念的ROP了（不是<br>
# 0. ROP的起源<br>
## 0.1 shellcode的限制： No-execute bit<br>
回想起之前在`shellcode`的章节里我们有说过`No-execute`这个功能，就是会给内存区域设置权限:<br>
```
PROT_READ: 允许进程读取
PROT_WRITE 允许进程写
PROT_EXEC: 允许进程执行
```
通常情况下，代码都位于**elf文件的.text segment中，stack和heap是没有必要授予执行权限的**<br>
事实也是如此，现代系统的栈和堆都不可执行。<br>
这也让我们无法注入代码让其执行了。但是这不是终点，**缺少了代码注入，我们将目标转向了代码复用**<br>
## 0.2 思想起源： Return-to-libc<br>
## 0.3 x86->x64时代的变迁<br>



<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-C22S5YSYL7"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-C22S5YSYL7');
</script>