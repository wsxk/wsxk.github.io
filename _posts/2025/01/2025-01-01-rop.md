---
layout: post
tags: [pwn]
title: "ROP"
author: wsxk
date: 2025-1-1
comments: true
---

- [0. ROP的起源](#0-rop的起源)
  - [0.1 shellcode的限制： No-execute bit](#01-shellcode的限制-no-execute-bit)
  - [0.2 思想起源： Return-to-libc](#02-思想起源-return-to-libc)
  - [0.3 x86-\>x64时代的变迁](#03-x86-x64时代的变迁)
- [1. ROP](#1-rop)
  - [1.1 ROP 归纳](#11-rop-归纳)
  - [1.2 ROP gadgets](#12-rop-gadgets)

终于到了最怀念的ROP了（不是<br>
# 0. ROP的起源<br>
## 0.1 shellcode的限制： No-execute bit<br>
回想起之前在`shellcode`的章节里我们有说过`No-execute`这个功能，就是会给内存区域设置权限:<br>
```
PROT_READ: 允许进程读取
PROT_WRITE 允许进程写
PROT_EXEC: 允许进程执行
```
通常情况下，代码都位于**elf文件的.text segment中，stack和heap是没有必要授予执行权限的**<br>
事实也是如此，现代系统的栈和堆都不可执行。<br>
这也让我们无法注入代码让其执行了。但是这不是终点，**缺少了代码注入，我们将目标转向了代码复用**<br>
## 0.2 思想起源： Return-to-libc<br>
过去在x86时代，函数参数也会通过stack来传递，在基于栈的溢出中，我们可以覆盖返回地址和参数<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-9-25/20241231185531.png)
通过精选构造参数，让函数返回值执行`system("/bin/sh")`<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-9-25/20241231185745.png)

## 0.3 x86->x64时代的变迁<br>
到了x64时代，函数参数不通过栈来传递（参数太多还是会用栈，不过绝大多数用不到）<br>
要通过栈溢出执行我们所需的函数，需要解决参数的问题。<br>
解决办法就是**代码复用（Code Reuse）**<br>
参考这段代码:<br>
```c
01 int main() {
02    char name[16];
03    read(0, name, 128);
04 }
05 int win() {
06    sendfile(1, open("/flag", 0), 0, 1024);
07 }
```
其运行main函数的栈结构如下图所示:<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-9-25/20241231190322.png)
通过精心构造输入，可让其执行`win`函数，窃取信息。<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2024-9-25/20241231190422.png)
**`ret2libc`的推广（或者说思路的一般化）就是ROP(Return Oriented Programming，面向返回的编程)**<br>
这个技术非常强大，到现在还在持续使用<br>

# 1. ROP<br>
## 1.1 ROP 归纳<br>
总结来说，ROP就是递归的完成如下步骤:<br>
```
Step 0: overflow the stack 

Step n: by controlling the return address, you trigger a gadget:
0x004005f3: pop rdi ; ret

Step n+1: when the gadget returns, it returns to an address you control (i.e., the next gadget)
```
通过链接这些gadgets，我们就可以构建一个rop练，并执行任意动作。<br>
## 1.2 ROP gadgets<br>
ROP中有许多小技巧需要牢记<br>
```
1、stack fix-up gadgets
这些gadget可以清理栈结构，跳过数据(data)部分。
pop r12; pop rdi; pop rsi; ret
add rsp, 0x40; ret
因为pop和add rsp并不会清空栈中的内容

2、storing values into registers
pop rax, ret

3、常见和不常见 gadgets
ret (at the end of every function)
leave; ret (at the end of many functions)
pop REG; ret (restoring callee-saved registers before returning)
mov rax, REG; ret (setting the return value before returning)
因为我们可以跳到汇报指令的中间部分，指令不必常见也能够出现在gadgets当中
比如: add rsp, 0x08; ret 中肯定包含了 add esp, 0x08

4、storing addresses into registers
lea gadgets有最好,但是实际上很稀有，绝大多数被使用在函数的开头或中间,不会靠近ret指令。
Alternative #1: push rsp; pop rax; ret (equivalent to mov rax, rsp) will get the stack address into rax.
Alternative #2: add rax, rsp; ret (not perfect, but will conceptually get rsp into rax)
Alternative #3: xchg rax, rsp; ret (swap rax and rsp. DANGEROUS, be careful)

5、stack pivot
俗称栈迁移
xchg rax, rsp; ret
pop rsp; ...; ret

6、data transfer
add byte [rcx], al ; pop rbp ; ret 需要提前设置好rcx

7、syscalls
syscall指令非常稀少，最好还是用libc里的函数

8、KNOW YOUR ENVIRONMENT
rop链不是运行在空的环境中的，运行环境中到处都是有用的地址，例如：
code, stack, heap addresses in registers
code, stack, heap addresses all over the stack
所以调试很重要！！！
```
如何才能找到ROP gadgets呢？<br>
当然是有现成的工具啦:<br>
[https://github.com/zardus/ctf-tools](https://github.com/zardus/ctf-tools)<br>


<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-C22S5YSYL7"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-C22S5YSYL7');
</script>