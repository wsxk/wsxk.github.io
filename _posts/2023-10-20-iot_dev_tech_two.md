---
layout: post
tags: [iot_dev]
title: "iot dev technology 2"
author: wsxk
comments: true
date: 2023-10-20
---

- [4. 上电之后：Boot Loader](#4-上电之后boot-loader)
  - [4.1 排查硬件是否正常执行](#41-排查硬件是否正常执行)
  - [4.2 验证boot loader](#42-验证boot-loader)
  - [4.3 CPU初始化——总结](#43-cpu初始化总结)
- [5. 驱动程序](#5-驱动程序)
- [6. 设计硬件抽象层](#6-设计硬件抽象层)
- [7. 菜鸟当自强：软件工程师硬起来](#7-菜鸟当自强软件工程师硬起来)

## 4. 上电之后：Boot Loader<br>
### 4.1 排查硬件是否正常执行<br>
上电之后，要一个一个排查错误，确保程序可以正确运行<br>
```
■　通过ICE在PC上的远程调试工具，在程序的第一行设定断点，确定程序有停下来。
■　检查CPU的PC（Program Counter）寄存器是否正确。
■　检查CPU内部RAM的内容是否和我们下载的可执行文件（Binary File）相同。
■　程序的第一行是设定CPU状态寄存器，执行这一行命令后停下来，观察CPU的状态寄存器是否如预期改变。
■　继续单步执行，确认PC寄存器是否会跟着改变（通常都是累加，除非执行到Function Call、goto或中断产生），且每行程序的执行结果都是正确的。
```
### 4.2 验证boot loader<br>
做完这个验证后，要验证`boot loader`是否顺利执行<br>
```
■　CPU寄存器操作测试。
■　Stack Pointer的设定是否正确？Function Call是否可正确运行？
■　中断矢量表设定是否正确？中断矢量程序是否可正确运行？
■　存储器初始化及其操作测试，并保证所有的存储器都可正常读或写（如果可以写入的话）。
■　将data段载入RAM,对BSS段设定初值。如果有程序段必须在ROM以外的存储器执行的话，Boot-Loader也要负责将其载入。在此阶段，我们必须保证当主程序执行起来后，程序中全局变量的初始值都是正确的。假使有需要被载入的程序段，也必须确认其可正确执行。
```
其中，对于`中断矢量表的验证`,需要注意以下几点<br>
```
■　中断矢量表数组,详细注解每个entry代表的中断源。
■　有的平台是CPU外接中断控制器，那就必须先完成中断控制器的驱动程序，才可能开始测试中断系统是否正常。
■　设定CPU的‘中断矢量表地址寄存器’（有些CPU的中断矢量表只能放在规定的地址，通常这种CPU就不会有中断矢量表寄存器），即告知CPU中断矢量表数组所在的地址。
（这里会发生错误：将中断矢量表设定在错误的地址，许多CPU会规定放置中断矢量表的地址必须是某个值的倍数）
■　设定CPU的中断控制寄存器，一般而言，每个中断都可以设定优先级，而CPU可以设定是否允许中断产生，或仅允许哪个优先级以上的中断才可被触发。
(这里会经常发生错误，中断优先级设置太低，导致中断无法被触发)
■　确定中断被触发之后，相应的ISR就会被执行。
（这里容易发生错误：中断矢量表中各个entry与中断源的对应关系错误，导致中断产生，却执行到错误的ISR）
■　提供ISR的写作范例，让写ISR的工程师不用知道中断系统的细节，基本上就是编写一个C的函数即可。
```
而对于`存储器`，有以下几点<br>
```
■  硬件方面来说，如果数据线或地址线连接错误，就会导致读写一直出现错误。
■  软件方面来说，有些存储器（如SRAM、NOR Flash及ROM）不需要额外设定，只要给对地址就可以直接使用，但是其他的存储器种类，以SDRAM为例，则必须通过额外的控制IC（SDRAM Controller）才能操作，程序必须先设定好SDRAM Controller的配置，如SDRAM的size、速度等，才能正确的access到SDRAM。假使某些参数设定错误，如size设定的比较小，则SDRAM或许还是可以动作，只是会access不到高地址的存储器。
■　系统中的存储器特性各异，所以当CPU在access不同的存储器时，一定要使用不同的时序（Timing）,至于外部存储器的时序该如何设定，则每种CPU都大不相同。你现在只要知道Boot-Loader必须负责设定各个外部存储器的时序。时序若设太快，系统会较不稳定；设太慢则系统整体性能变差。CPU的data sheet中通常会提示CPU在什么速度下使用什么存储器，Timing应该如何设定
■　在把板子与Boot-Loader交付给其他人员之前，一定要把各个存储器的每一个Byte都测过，确定读写（如果能写的话）都没问题。
另外一个问题，假使存储器不能在执行时被写入（如ROM）,或者即便有方法可以写入，一旦存储器中的内容是有意义且不容破坏的（如用来存储程序的NOR Flash）,在执行时，Boot-Loader该如何验证ROM或NOR Flash中的数据是正确的呢？
——一般来说，有许多方法可以采用，最简单的就是计算checksum,我们会分别在PC为image file算checksum,另外在机器上为ROM或NOR Flash计算checksum,只要这两者值是相同的，我们就可以说机器上的ROM或NOR Flash读取功能正常，而且也可以顺便验证存储器的内容是否正确。
```

### 4.3 CPU初始化——总结<br>
对先前的内容做个总结:这里只总结到，**迁移data段数据之前**<br>
■　设定Stack Point寄存器。<br>
■　设定状态寄存器，至少在此阶段要禁止（Disable）中断产生。<br>
■　设定中断矢量表指针。<br>
■　设定CPU执行状态（用于嵌入式系统的CPU通常都具有省电功能，可以让CPU以不同的速度执行。<br>
■　设定存储器控制器（如果有用到像SDRAM的存储器的话）。<br>
■　设定CPU操作各个存储器的时序。<br>
■　有些CPU的PIN脚可以有多个功能，可以通过设定寄存器来设定。在Boot-Loader阶段，尽可能把这种多功能的PIN脚设定为我们系统定义的用途。<br>
■　通常我们会选用已经整合许多外围设备的CPU,如：LCD Controller、USB Controller或SD卡接口等，虽然这已经算是驱动程序的范畴了，但如果有必要的话，也可以在Boot-Loader阶段就先初始化这些外围。<br>



## 5. 驱动程序<br>

## 6. 设计硬件抽象层<br>

## 7. 菜鸟当自强：软件工程师硬起来<br>
第11章：菜鸟当自强：软件工程师硬起来■　
第12章：做好存储器管理■　
第13章：存储器管理（II）：NAND Flash概论■　
第14章：模拟器■　
附录B：Callback Function■　
附录C：用C来实作面向对象的概念