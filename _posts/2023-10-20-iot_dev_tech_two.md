---
layout: post
tags: [iot_dev]
title: "iot dev technology 2"
author: wsxk
comments: true
date: 2023-10-20
---

- [4. 上电之后：Boot Loader](#4-上电之后boot-loader)
  - [4.1 排查硬件是否正常执行](#41-排查硬件是否正常执行)
  - [4.2 验证boot loader](#42-验证boot-loader)
  - [4.3 CPU初始化——总结](#43-cpu初始化总结)
  - [4.4 载入程序段](#44-载入程序段)
- [5. 驱动程序](#5-驱动程序)
  - [5.1 驱动程序分层](#51-驱动程序分层)
  - [5.2 驱动程序开发前的准备](#52-驱动程序开发前的准备)
  - [5.3 控制CPU](#53-控制cpu)
    - [5.3.1 控制CPU寄存器](#531-控制cpu寄存器)
    - [5.3.2 控制中断处理器](#532-控制中断处理器)
    - [5.3.4 Clock](#534-clock)
- [6. 设计硬件抽象层](#6-设计硬件抽象层)
- [7. 菜鸟当自强：软件工程师硬起来](#7-菜鸟当自强软件工程师硬起来)

## 4. 上电之后：Boot Loader<br>
### 4.1 排查硬件是否正常执行<br>
上电之后，要一个一个排查错误，确保程序可以正确运行<br>
```
■　通过ICE在PC上的远程调试工具，在程序的第一行设定断点，确定程序有停下来。
■　检查CPU的PC（Program Counter）寄存器是否正确。
■　检查CPU内部RAM的内容是否和我们下载的可执行文件（Binary File）相同。
■　程序的第一行是设定CPU状态寄存器，执行这一行命令后停下来，观察CPU的状态寄存器是否如预期改变。
■　继续单步执行，确认PC寄存器是否会跟着改变（通常都是累加，除非执行到Function Call、goto或中断产生），且每行程序的执行结果都是正确的。
```
### 4.2 验证boot loader<br>
做完这个验证后，要验证`boot loader`是否顺利执行<br>
```
■　CPU寄存器操作测试。
■　Stack Pointer的设定是否正确？Function Call是否可正确运行？
■　中断矢量表设定是否正确？中断矢量程序是否可正确运行？
■　存储器初始化及其操作测试，并保证所有的存储器都可正常读或写（如果可以写入的话）。
■　将data段载入RAM,对BSS段设定初值。如果有程序段必须在ROM以外的存储器执行的话，Boot-Loader也要负责将其载入。在此阶段，我们必须保证当主程序执行起来后，程序中全局变量的初始值都是正确的。假使有需要被载入的程序段，也必须确认其可正确执行。
```
其中，对于`中断矢量表的验证`,需要注意以下几点<br>
```
■　中断矢量表数组,详细注解每个entry代表的中断源。
■　有的平台是CPU外接中断控制器，那就必须先完成中断控制器的驱动程序，才可能开始测试中断系统是否正常。
■　设定CPU的‘中断矢量表地址寄存器’（有些CPU的中断矢量表只能放在规定的地址，通常这种CPU就不会有中断矢量表寄存器），即告知CPU中断矢量表数组所在的地址。
（这里会发生错误：将中断矢量表设定在错误的地址，许多CPU会规定放置中断矢量表的地址必须是某个值的倍数）
■　设定CPU的中断控制寄存器，一般而言，每个中断都可以设定优先级，而CPU可以设定是否允许中断产生，或仅允许哪个优先级以上的中断才可被触发。
(这里会经常发生错误，中断优先级设置太低，导致中断无法被触发)
■　确定中断被触发之后，相应的ISR就会被执行。
（这里容易发生错误：中断矢量表中各个entry与中断源的对应关系错误，导致中断产生，却执行到错误的ISR）
■　提供ISR的写作范例，让写ISR的工程师不用知道中断系统的细节，基本上就是编写一个C的函数即可。
```
而对于`存储器`，有以下几点<br>
```
■  硬件方面来说，如果数据线或地址线连接错误，就会导致读写一直出现错误。
■  软件方面来说，有些存储器（如SRAM、NOR Flash及ROM）不需要额外设定，只要给对地址就可以直接使用，但是其他的存储器种类，以SDRAM为例，则必须通过额外的控制IC（SDRAM Controller）才能操作，程序必须先设定好SDRAM Controller的配置，如SDRAM的size、速度等，才能正确的access到SDRAM。假使某些参数设定错误，如size设定的比较小，则SDRAM或许还是可以动作，只是会access不到高地址的存储器。
■　系统中的存储器特性各异，所以当CPU在access不同的存储器时，一定要使用不同的时序（Timing）,至于外部存储器的时序该如何设定，则每种CPU都大不相同。你现在只要知道Boot-Loader必须负责设定各个外部存储器的时序。时序若设太快，系统会较不稳定；设太慢则系统整体性能变差。CPU的data sheet中通常会提示CPU在什么速度下使用什么存储器，Timing应该如何设定
■　在把板子与Boot-Loader交付给其他人员之前，一定要把各个存储器的每一个Byte都测过，确定读写（如果能写的话）都没问题。
另外一个问题，假使存储器不能在执行时被写入（如ROM）,或者即便有方法可以写入，一旦存储器中的内容是有意义且不容破坏的（如用来存储程序的NOR Flash）,在执行时，Boot-Loader该如何验证ROM或NOR Flash中的数据是正确的呢？
——一般来说，有许多方法可以采用，最简单的就是计算checksum,我们会分别在PC为image file算checksum,另外在机器上为ROM或NOR Flash计算checksum,只要这两者值是相同的，我们就可以说机器上的ROM或NOR Flash读取功能正常，而且也可以顺便验证存储器的内容是否正确。
```

### 4.3 CPU初始化——总结<br>
对先前的内容做个总结:这里只总结到，**迁移data段数据之前**<br>
■　设定Stack Point寄存器。<br>
■　设定状态寄存器，至少在此阶段要禁止（Disable）中断产生。<br>
■　设定中断矢量表指针。<br>
■　设定CPU执行状态（用于嵌入式系统的CPU通常都具有省电功能，可以让CPU以不同的速度执行。<br>
■　设定存储器控制器（如果有用到像SDRAM的存储器的话）。<br>
■　设定CPU操作各个存储器的时序。<br>
■　有些CPU的PIN脚可以有多个功能，可以通过设定寄存器来设定。在Boot-Loader阶段，尽可能把这种多功能的PIN脚设定为我们系统定义的用途。<br>
■　通常我们会选用已经整合许多外围设备的CPU,如：LCD Controller、USB Controller或SD卡接口等，虽然这已经算是驱动程序的范畴了，但如果有必要的话，也可以在Boot-Loader阶段就先初始化这些外围。<br>

### 4.4 载入程序段<br>
data与bss段之外，**需要加速的程序模块可以看情况Boot-Loader阶段传输**<br>
存储器的速度：**CPU 寄存器>CPU Cache>CPU 内部存储器（Internal）>外部 SRAM>NOR Flash>SDRAM>Mask ROM>NAND Flash**<br>
`Nor Flash是可以重复写入的ROM)`，`Nand Flash(P3随身听、随身碟中的存储装置就是NAND Flash，它是目前单位容量最便宜的存储器。)Nand Flash无法直接执行程序`<br>

## 5. 驱动程序<br>
**驱动程序是系统的基础，基础不稳定如同房子底层发生小小的摇动，传导到上层就会感觉是大地震，所以驱动程序稳定度的重要性众所周知**<br>
一般人总会认为嵌入式系统和PC程序最大的不同，就是前者有一堆驱动程序要自己编写，这种想法当然不完全正确，经过前面几个章节的探讨,我们知道嵌入式系统的开发不仅仅只是开发非PC平台的程序而已，它有着诸多的限制，如：CPU计算能力、存储器大小、成本及进度等。每一位工程师，无论是开发驱动程序还是应用程序，都应该要了解目前正在开发的产品的本质与特性，如果用写PC程序的思想来开发嵌入式系统，无疑就像在系统中埋下一堆不定时炸弹。<br>
举一个经常发生的案例：在PC程序的某个函数中，定义一个有1024个长整数的数组（4096 Byte）不会有任何问题，但在嵌入式系统中就可能造成Stack Overflow（假设系统的Stack size为2048 Bytes ）。更麻烦的是，假使测试时没有把数组中所有的元素都设定数值，可能还不会出问题，一旦等到发生较极端的状况，当高地址的元素被写入值了，stack之外的存储器就会被破坏，而且假使被破坏的存储器不会马上被用到，而该工程师还浑然不觉函数已出现问题，要等到被破坏的存储器被使用时，系统才会出状况。此时正在执行的功能（function B）可能和罪魁祸首所在的函数（function A）完全无关，工程师会误判问题的来源，就算把function B从头到尾看一次，也看不出个所以然，因为问题是出在和function B完全不相关的function A身上。<br><br>
### 5.1 驱动程序分层<br>
Windows或Linux的开发环境都已经有稳定的操作系统，要增加对新硬件设备的支持，驱动程序自然要遵循操作系统的规定,但是嵌入式却是反过来的，**当产品的功能确定后，硬件规格的定义会比系统设计早完成，而且为了让硬件板子出来时就有测试程序可供验证，在硬件设计阶段，你们就已经在评估板上开始开发驱动程序了。在这个阶段，系统还在设计呢**<br>
然而，需要注意的是，也并不是所有嵌入式系统驱动设计会比系统设计更早完成，不管先有系统还是先有驱动程序，嵌入式系统的驱动程序架构绝对要清晰简单，一般来说最多就是两层。<br>
```
■　Driver层：真正驱动硬件设备的程序，上层的程序不应该直接调用到这层的函数。
■　API层：根据系统或应用程序的需求，将driver层包装成较简单的接口，这应该是上层程序与硬件沟通的唯一管道。API接口会隐藏所有的硬件细节。
```
理论上API层的函数应该由使用这些API的人负责定义，只有他们才知道系统或应用程序需要用到哪些硬件的功能，可是他们显然比较不清楚硬件特性的细节，也不知道哪些功能可以实现，哪些功能可能做不到。所以实际上都会由负责固件开发的工程师，先根据硬件的特性与对最终产品的了解，先行定义驱动程序API的初版，然后再提交给将来会使用的单位参考，并根据其反馈做修正<br><br>

### 5.2 驱动程序开发前的准备<br>
需要记住一点**驱动程序在整个系统开发中是属于没机会发挥个人创意的工作，若CPU或外围IC规定就是要照某些步骤执行它才能正常运行，你就不可能用其他方法让它动。**<br>
首先有一些资源需要了解<br>
```
■　IC原厂的技术人员或代理商的FAE
■　评估板
■　范例程序代码（Sample Code）
■　产品规格书（Data Sheet）
■　硬件板子设计规格书
■　原理图与Layout图
```
另外，使用`c语言写驱动程序，就算有必须用汇编进行操纵的步骤，也可以使用内联汇编（inline assembly）来解决`<br>
```
■　volatile变量：操作CPU内Memory Mapping Register的方法就是使用C语言的指针，为避免相关程序被优化
■　Inline Assembly：现代的嵌入式系统开发，为了可移植性、可维护性等原因，除了要操作CPU内部寄存器及对某个模块做性能调整外，用汇编语言写程序的机会不多，通常我们也会用Inline Assembly，免去汇编语言函数与C语言函数间互相调用时的麻烦
■　中断处理程序（ISR）的写法：虽说ISR其实就是一个C的函数，但ISR的起始和结尾与一般的函数还是有点不同。简单地说，在ISR开始时要将所有寄存器都存储在Stack Memory中，结束前要恢复这些寄存器的值，而且一般函数是用‘return’，的指令返回调用的函数，而ISR必须用‘interrupt return’的指令返回被中断的程序。原本这些细节都要写ISR的工程师自己写，有的编译器会提供额外的语法，如在函数声明时多加一个描述字符串‘__interrupt__’，则编译器碰到这样的函数时，就会自动加上存储/恢复寄存器的指令，并用‘interrup treturn’指令来返回中断发生点，这样就不用写这些细节了。
```
当产品规格定义完成以及硬件架构大致底定后，Driver API就可以开始进行设计了。我想在设计这套API时，应该要将重心放在系统式与应用程序的需求上；对于硬件设计，我们只需确认其确实能够达成这些API的功能，至于硬件电路的细节应该不会影响Driver API的设计.<br><br>
实际上我们会把.h文件和包含空函数的.c文件先写好，这样的好处是在驱动程序还没稳定之前，不会影响系统的编译，其他的程序都可以同步开发。如此一来，我们会接收到其他人员对Driver API的意见，有必要的话，也可以尽早修改设计。<br><br>
此外，***我们一般称Driver API为硬件抽象层（Hardware Abstract Level; HAL），它对嵌入式系统开发还有一项重要的意义。因为Driver API上层的程序都是和硬件无关的，所以负责模拟器的人员只要在PC上模拟出这些API的行为，其他上层的程序应该完全不需要任何更动，就可以在机器与模拟器上运行，这样的架构自然会让系统具备较佳的可移植性。***<br>
### 5.3 控制CPU<br>
在Boot-Loader阶段，我们已经完成了CPU的初始化，但是在Boot-Loader阶段，我们只是简单地设定CPU的状态寄存器，以及中断矢量表的指针，而且还禁止了中断产生，所以CPU的功能还没完全开放，我们必须再设定一些寄存器，才能让CPU完全开放所有功能。<br>
下图是一个`CPU的架构图(CPU内整合许多外围设备的设计已蔚为风尚)`<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2023-7-6/20231027203642.png)
#### 5.3.1 控制CPU寄存器<br>
写汇编语言时，会遇到的寄存器如下:<br>
```
■　可以直接设定值的状态寄存器。例如，我们在系统启动后，要马上设定STACK存储器的地址，否则函数调用以及中断处理程序都会运行不正常。此时，我们会写如下的汇编语言去设定CPU的Stack Point（SP）寄存器。此外，我们可以从之前提过的CPU状态寄存器（PSR），从中知道CPU执行了某个指令之后的状态，也可以设定其中某个bit的值来控制CPU的行为，最常用的就是设定IE（Interrupt Enable）这个bit，可允许或禁止中断发生。
■　不允许赋值的寄存器。如PC（Program Counter）寄存器，存储CPU接下来要执行指令的地址，当CPU自存储器获取了一个指令来执行时，PC寄存器会自动累加，程序不允许直接设定PC寄存器的值，只能通过jump、call等指令来改变执行顺序时，才会使得PC值跟着改变。
```
除此之外，还要一种叫做**Memory Mapping 寄存器**的寄存器<br>
先不管硬件原理的细节，就写驱动程序的人来说，要控制接在CPU外部的芯片势必是通过CPU的PIN脚，可能只是简单的将GPIO脚（General Purpose I/O）设为High或Low来控制外部的chip。同理，外部的设备也可以通过GPIO脚将信号传回给CPU，或者驱动程序可以通过某种通信协议来控制I/C，如SPI或I2C或等。但无论是什么样的通信协议，CPU和外部chip间数据与命令的传递，还是要通过CPU的PIN脚<br>
假使这个chip是整合到CPU内部，姑且不管它与CPU的core是怎么连接的，驱动程序肯定不是通过操作CPU的PIN脚来控制CPU内部的chip。CPU设计者为了让整合进来的chip确实像是CPU的一部分，会把该chip的特性包装起来，所以驱动程序工程师看到的就是一系列的寄存器，通过设定这些寄存器的值，等于通知CPU Core去操作整合进来的chip，而该chip要传递信息给驱动程序时，也是通过这些寄存器。<br>
这种用来控制CPU内部chip的寄存器，与刚刚提到的CPU内部寄存器是完全不同的性质，CPU内部寄存器有自己的名字，而内部外围设备的寄存器只有一个地址，所以通常我们称之为**Memory Mapping Register**，而这种控制内置chip的方式称为memory mapping I/O。<br><br>
#### 5.3.2 控制中断处理器<br>
驱动程序在控制中断系统时要注意的事项有<br>
```
■　Boot之后应立刻禁止中断产生（应该都是设定PSR），因为除了中断系统还没设定好之外，可能产生中断的硬设备也还没初始化完毕。

■　内置中断处理器的CPU会规定哪些PIN脚是可以产生中断的，而哪些PIN脚会产生什么中断通常也是定义好的。例如，内置USB Controller的CPU，可能就会规定某根PIN脚用来接收USB设备的中断信号，所以在硬件设计时，一定要注意CPU与中断有关的相关规范。举例来说，如果键盘输入接到CPU不会产生中断的PIN脚，则程序只能用polling（查询）的方式，一直去察看有没有key被按下（该PIN脚的电位是否改变），这是很缺乏效率的设计。

■　固件工程师必须知道什么设备接到CPU的哪一根PIN脚，是否会引发中断，如果会的话，又是第几号中断，一定要弄清楚相关的硬件设计，否则怎么有办法写该设备的驱动程序？

■　设定中断矢量表的起始地址（通常都是通过寄存器来设定），中断矢量表可以写成一个C的数组，数组内的元素就是各个ISR的地址。

■　我们的产品不见得会用到所有CPU支持的中断来源，也就是说，并非每一个中断矢量表的entry都有对应的ISR，但中断矢量表的每一个entry都必须有值，此时就必须为这些没有用到的中断来源写一个空的ISR。当这个空的ISR被执行时，就表示有不该产生的中断产生了，这可能是硬件设计错误或静电产生的误动作，必须通知硬件人员处理。

■　驱动程序可以通过设定寄存器为每一个中断来源设定优先级（一般CPU都是8个等级），PSR寄存器中除了可以设定中断是否可以产生之外，也可以设定哪一个优先级以下的中断不会被CPU处理。

■　一般情况下，除非产品有hard real time的应用，否则我们不允许巢状中断（ISR在执行时允许发生中断，于是ISR可能被中断，CPU去执行另一个ISR），即ISR执行时期禁止中断产生，这是因为巢状中断会出现很复杂的状况。此时，可以通过设定CPU允许产生中断的优先级。例如，一般中断的优先级都是6,而不允许任何等待或丢失的中断事件则设为7，平常ISR执行时设定CPU仅允许优先级7以上的中断产生，则所有优先级6的中断不会产生巢状中断，但优先级7的中断在任何时候都保证会被处理。

■　有一个比较特殊的中断叫做NMI（Non-Maskable Interrupt；不可屏蔽式中断），顾名思义，就是无论如何都不会被禁止的中断，硬件设计时可以把hard real time的中断来源接到NMI上。

■　ISR也是一个函数，但有很多注意事项要遵守，尤其是critical section的保护，稍后我们会再提到。

此外，ISR不像一般程序是循序执行的，它会在任何程序在执行时被调用，可能发生的状况很多，所以我会要求对ISR进行更严格的测试。
```

#### 5.3.4 Clock<br>
**所谓的Clock是维持CPU正常运行所需的基本时间单位**<br>
系统中的CPU和存储器应该要有一个统一的时间基准，我们称之为时序。例如，我们说某颗Pentium 4 CPU是2GHz的，则表示这颗CPU运行的基本时间单位为1/（2×1024×1024）秒，这里所说的基本时间单位可以简称为一个Clock。如果CPU一个Clock可以执行一个指令，那么一个Clock越短的CPU，在每1秒内就可以执行更多的指令，对使用者而言，这颗CPU的性能也就越好。<br>
**这就是所谓CPU‘超频’的原理！同一颗CPU使用不同的时序就会有运算速度不同的效果。**<br>
**CPU的Clock是由外部的Clock Generator提供的，例如振荡器IC（之所以用振荡器IC是为了获取稳定的时序）**<br>



## 6. 设计硬件抽象层<br>

## 7. 菜鸟当自强：软件工程师硬起来<br>
第11章：菜鸟当自强：软件工程师硬起来■　
第12章：做好存储器管理■　
第13章：存储器管理（II）：NAND Flash概论■　
第14章：模拟器■　
附录B：Callback Function■　
附录C：用C来实作面向对象的概念