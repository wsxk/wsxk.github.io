---
layout: post
tags: [iot_dev]
title: "iot dev technology 2"
author: wsxk
comments: true
date: 2023-10-20
---

- [4. 上电之后：Boot Loader](#4-上电之后boot-loader)
  - [4.1 排查硬件是否正常执行](#41-排查硬件是否正常执行)
  - [4.2 验证boot loader](#42-验证boot-loader)
  - [4.3 验证](#43-验证)
- [5. 驱动程序](#5-驱动程序)
- [6. 设计硬件抽象层](#6-设计硬件抽象层)
- [7. 菜鸟当自强：软件工程师硬起来](#7-菜鸟当自强软件工程师硬起来)

## 4. 上电之后：Boot Loader<br>
### 4.1 排查硬件是否正常执行<br>
上电之后，要一个一个排查错误，确保程序可以正确运行<br>
```
■　通过ICE在PC上的远程调试工具，在程序的第一行设定断点，确定程序有停下来。
■　检查CPU的PC（Program Counter）寄存器是否正确。
■　检查CPU内部RAM的内容是否和我们下载的可执行文件（Binary File）相同。
■　程序的第一行是设定CPU状态寄存器，执行这一行命令后停下来，观察CPU的状态寄存器是否如预期改变。
■　继续单步执行，确认PC寄存器是否会跟着改变（通常都是累加，除非执行到Function Call、goto或中断产生），且每行程序的执行结果都是正确的。
```
### 4.2 验证boot loader<br>
做完这个验证后，要验证`boot loader`是否顺利执行<br>
```
■　CPU寄存器操作测试。
■　Stack Pointer的设定是否正确？Function Call是否可正确运行？
■　中断矢量表设定是否正确？中断矢量程序是否可正确运行？
■　存储器初始化及其操作测试，并保证所有的存储器都可正常读或写（如果可以写入的话）。
■　将data段载入RAM,对BSS段设定初值。如果有程序段必须在ROM以外的存储器执行的话，Boot-Loader也要负责将其载入。在此阶段，我们必须保证当主程序执行起来后，程序中全局变量的初始值都是正确的。假使有需要被载入的程序段，也必须确认其可正确执行。
```
其中，对于`中断矢量表的验证`,需要注意以下几点<br>
```
■　中断矢量表数组,详细注解每个entry代表的中断源。
■　有的平台是CPU外接中断控制器，那就必须先完成中断控制器的驱动程序，才可能开始测试中断系统是否正常。
■　设定CPU的‘中断矢量表地址寄存器’（有些CPU的中断矢量表只能放在规定的地址，通常这种CPU就不会有中断矢量表寄存器），即告知CPU中断矢量表数组所在的地址。
（这里会发生错误：将中断矢量表设定在错误的地址，许多CPU会规定放置中断矢量表的地址必须是某个值的倍数）
■　设定CPU的中断控制寄存器，一般而言，每个中断都可以设定优先级，而CPU可以设定是否允许中断产生，或仅允许哪个优先级以上的中断才可被触发。
(这里会经常发生错误，中断优先级设置太低，导致中断无法被触发)
■　确定中断被触发之后，相应的ISR就会被执行。
（这里容易发生错误：中断矢量表中各个entry与中断源的对应关系错误，导致中断产生，却执行到错误的ISR）
■　提供ISR的写作范例，让写ISR的工程师不用知道中断系统的细节，基本上就是编写一个C的函数即可。
```
### 4.3 验证

## 5. 驱动程序<br>

## 6. 设计硬件抽象层<br>

## 7. 菜鸟当自强：软件工程师硬起来<br>
第11章：菜鸟当自强：软件工程师硬起来■　
第12章：做好存储器管理■　
第13章：存储器管理（II）：NAND Flash概论■　
第14章：模拟器■　
附录B：Callback Function■　
附录C：用C来实作面向对象的概念