---
layout: post
tags: [iot_dev]
title: "iot dev technology 2"
author: wsxk
comments: true
date: 2023-10-20
---

- [4. 上电之后：Boot Loader](#4-上电之后boot-loader)
  - [4.1 排查硬件是否正常执行](#41-排查硬件是否正常执行)
  - [4.2 验证boot loader](#42-验证boot-loader)
  - [4.3 CPU初始化——总结](#43-cpu初始化总结)
  - [4.4 载入程序段](#44-载入程序段)
- [5. 驱动程序](#5-驱动程序)
  - [5.1 驱动程序分层](#51-驱动程序分层)
  - [5.2 驱动程序开发前的准备](#52-驱动程序开发前的准备)
- [6. 设计硬件抽象层](#6-设计硬件抽象层)
- [7. 菜鸟当自强：软件工程师硬起来](#7-菜鸟当自强软件工程师硬起来)

## 4. 上电之后：Boot Loader<br>
### 4.1 排查硬件是否正常执行<br>
上电之后，要一个一个排查错误，确保程序可以正确运行<br>
```
■　通过ICE在PC上的远程调试工具，在程序的第一行设定断点，确定程序有停下来。
■　检查CPU的PC（Program Counter）寄存器是否正确。
■　检查CPU内部RAM的内容是否和我们下载的可执行文件（Binary File）相同。
■　程序的第一行是设定CPU状态寄存器，执行这一行命令后停下来，观察CPU的状态寄存器是否如预期改变。
■　继续单步执行，确认PC寄存器是否会跟着改变（通常都是累加，除非执行到Function Call、goto或中断产生），且每行程序的执行结果都是正确的。
```
### 4.2 验证boot loader<br>
做完这个验证后，要验证`boot loader`是否顺利执行<br>
```
■　CPU寄存器操作测试。
■　Stack Pointer的设定是否正确？Function Call是否可正确运行？
■　中断矢量表设定是否正确？中断矢量程序是否可正确运行？
■　存储器初始化及其操作测试，并保证所有的存储器都可正常读或写（如果可以写入的话）。
■　将data段载入RAM,对BSS段设定初值。如果有程序段必须在ROM以外的存储器执行的话，Boot-Loader也要负责将其载入。在此阶段，我们必须保证当主程序执行起来后，程序中全局变量的初始值都是正确的。假使有需要被载入的程序段，也必须确认其可正确执行。
```
其中，对于`中断矢量表的验证`,需要注意以下几点<br>
```
■　中断矢量表数组,详细注解每个entry代表的中断源。
■　有的平台是CPU外接中断控制器，那就必须先完成中断控制器的驱动程序，才可能开始测试中断系统是否正常。
■　设定CPU的‘中断矢量表地址寄存器’（有些CPU的中断矢量表只能放在规定的地址，通常这种CPU就不会有中断矢量表寄存器），即告知CPU中断矢量表数组所在的地址。
（这里会发生错误：将中断矢量表设定在错误的地址，许多CPU会规定放置中断矢量表的地址必须是某个值的倍数）
■　设定CPU的中断控制寄存器，一般而言，每个中断都可以设定优先级，而CPU可以设定是否允许中断产生，或仅允许哪个优先级以上的中断才可被触发。
(这里会经常发生错误，中断优先级设置太低，导致中断无法被触发)
■　确定中断被触发之后，相应的ISR就会被执行。
（这里容易发生错误：中断矢量表中各个entry与中断源的对应关系错误，导致中断产生，却执行到错误的ISR）
■　提供ISR的写作范例，让写ISR的工程师不用知道中断系统的细节，基本上就是编写一个C的函数即可。
```
而对于`存储器`，有以下几点<br>
```
■  硬件方面来说，如果数据线或地址线连接错误，就会导致读写一直出现错误。
■  软件方面来说，有些存储器（如SRAM、NOR Flash及ROM）不需要额外设定，只要给对地址就可以直接使用，但是其他的存储器种类，以SDRAM为例，则必须通过额外的控制IC（SDRAM Controller）才能操作，程序必须先设定好SDRAM Controller的配置，如SDRAM的size、速度等，才能正确的access到SDRAM。假使某些参数设定错误，如size设定的比较小，则SDRAM或许还是可以动作，只是会access不到高地址的存储器。
■　系统中的存储器特性各异，所以当CPU在access不同的存储器时，一定要使用不同的时序（Timing）,至于外部存储器的时序该如何设定，则每种CPU都大不相同。你现在只要知道Boot-Loader必须负责设定各个外部存储器的时序。时序若设太快，系统会较不稳定；设太慢则系统整体性能变差。CPU的data sheet中通常会提示CPU在什么速度下使用什么存储器，Timing应该如何设定
■　在把板子与Boot-Loader交付给其他人员之前，一定要把各个存储器的每一个Byte都测过，确定读写（如果能写的话）都没问题。
另外一个问题，假使存储器不能在执行时被写入（如ROM）,或者即便有方法可以写入，一旦存储器中的内容是有意义且不容破坏的（如用来存储程序的NOR Flash）,在执行时，Boot-Loader该如何验证ROM或NOR Flash中的数据是正确的呢？
——一般来说，有许多方法可以采用，最简单的就是计算checksum,我们会分别在PC为image file算checksum,另外在机器上为ROM或NOR Flash计算checksum,只要这两者值是相同的，我们就可以说机器上的ROM或NOR Flash读取功能正常，而且也可以顺便验证存储器的内容是否正确。
```

### 4.3 CPU初始化——总结<br>
对先前的内容做个总结:这里只总结到，**迁移data段数据之前**<br>
■　设定Stack Point寄存器。<br>
■　设定状态寄存器，至少在此阶段要禁止（Disable）中断产生。<br>
■　设定中断矢量表指针。<br>
■　设定CPU执行状态（用于嵌入式系统的CPU通常都具有省电功能，可以让CPU以不同的速度执行。<br>
■　设定存储器控制器（如果有用到像SDRAM的存储器的话）。<br>
■　设定CPU操作各个存储器的时序。<br>
■　有些CPU的PIN脚可以有多个功能，可以通过设定寄存器来设定。在Boot-Loader阶段，尽可能把这种多功能的PIN脚设定为我们系统定义的用途。<br>
■　通常我们会选用已经整合许多外围设备的CPU,如：LCD Controller、USB Controller或SD卡接口等，虽然这已经算是驱动程序的范畴了，但如果有必要的话，也可以在Boot-Loader阶段就先初始化这些外围。<br>

### 4.4 载入程序段<br>
data与bss段之外，**需要加速的程序模块可以看情况Boot-Loader阶段传输**<br>
存储器的速度：**CPU 寄存器>CPU Cache>CPU 内部存储器（Internal）>外部 SRAM>NOR Flash>SDRAM>Mask ROM>NAND Flash**<br>
`Nor Flash是可以重复写入的ROM)`，`Nand Flash(P3随身听、随身碟中的存储装置就是NAND Flash，它是目前单位容量最便宜的存储器。)Nand Flash无法直接执行程序`<br>

## 5. 驱动程序<br>
**驱动程序是系统的基础，基础不稳定如同房子底层发生小小的摇动，传导到上层就会感觉是大地震，所以驱动程序稳定度的重要性众所周知**<br>
一般人总会认为嵌入式系统和PC程序最大的不同，就是前者有一堆驱动程序要自己编写，这种想法当然不完全正确，经过前面几个章节的探讨,我们知道嵌入式系统的开发不仅仅只是开发非PC平台的程序而已，它有着诸多的限制，如：CPU计算能力、存储器大小、成本及进度等。每一位工程师，无论是开发驱动程序还是应用程序，都应该要了解目前正在开发的产品的本质与特性，如果用写PC程序的思想来开发嵌入式系统，无疑就像在系统中埋下一堆不定时炸弹。<br>
举一个经常发生的案例：在PC程序的某个函数中，定义一个有1024个长整数的数组（4096 Byte）不会有任何问题，但在嵌入式系统中就可能造成Stack Overflow（假设系统的Stack size为2048 Bytes ）。更麻烦的是，假使测试时没有把数组中所有的元素都设定数值，可能还不会出问题，一旦等到发生较极端的状况，当高地址的元素被写入值了，stack之外的存储器就会被破坏，而且假使被破坏的存储器不会马上被用到，而该工程师还浑然不觉函数已出现问题，要等到被破坏的存储器被使用时，系统才会出状况。此时正在执行的功能（function B）可能和罪魁祸首所在的函数（function A）完全无关，工程师会误判问题的来源，就算把function B从头到尾看一次，也看不出个所以然，因为问题是出在和function B完全不相关的function A身上。<br><br>
### 5.1 驱动程序分层<br>
Windows或Linux的开发环境都已经有稳定的操作系统，要增加对新硬件设备的支持，驱动程序自然要遵循操作系统的规定,但是嵌入式却是反过来的，**当产品的功能确定后，硬件规格的定义会比系统设计早完成，而且为了让硬件板子出来时就有测试程序可供验证，在硬件设计阶段，你们就已经在评估板上开始开发驱动程序了。在这个阶段，系统还在设计呢**<br>
然而，需要注意的是，也并不是所有嵌入式系统驱动设计会比系统设计更早完成，不管先有系统还是先有驱动程序，嵌入式系统的驱动程序架构绝对要清晰简单，一般来说最多就是两层。<br>
```
■　Driver层：真正驱动硬件设备的程序，上层的程序不应该直接调用到这层的函数。
■　API层：根据系统或应用程序的需求，将driver层包装成较简单的接口，这应该是上层程序与硬件沟通的唯一管道。API接口会隐藏所有的硬件细节。
```
理论上API层的函数应该由使用这些API的人负责定义，只有他们才知道系统或应用程序需要用到哪些硬件的功能，可是他们显然比较不清楚硬件特性的细节，也不知道哪些功能可以实现，哪些功能可能做不到。所以实际上都会由负责固件开发的工程师，先根据硬件的特性与对最终产品的了解，先行定义驱动程序API的初版，然后再提交给将来会使用的单位参考，并根据其反馈做修正<br><br>

### 5.2 驱动程序开发前的准备<br>
需要记住一点**驱动程序在整个系统开发中是属于没机会发挥个人创意的工作，若CPU或外围IC规定就是要照某些步骤执行它才能正常运行，你就不可能用其他方法让它动。**<br>
首先有一些资源需要了解<br>
```
■　IC原厂的技术人员或代理商的FAE
■　评估板
■　范例程序代码（Sample Code）
■　产品规格书（Data Sheet）
■　硬件板子设计规格书
■　原理图与Layout图
```
另外，使用`c语言写驱动程序，就算有必须用汇编进行操纵的步骤，也可以使用内联汇编（inline assembly）来解决`<br>
```
■　volatile变量：操作CPU内Memory Mapping Register的方法就是使用C语言的指针，为避免相关程序被优化
■　Inline Assembly：现代的嵌入式系统开发，为了可移植性、可维护性等原因，除了要操作CPU内部寄存器及对某个模块做性能调整外，用汇编语言写程序的机会不多，通常我们也会用Inline Assembly，免去汇编语言函数与C语言函数间互相调用时的麻烦
■　中断处理程序（ISR）的写法：虽说ISR其实就是一个C的函数，但ISR的起始和结尾与一般的函数还是有点不同。简单地说，在ISR开始时要将所有寄存器都存储在Stack Memory中，结束前要恢复这些寄存器的值，而且一般函数是用‘return’，的指令返回调用的函数，而ISR必须用‘interrupt return’的指令返回被中断的程序。原本这些细节都要写ISR的工程师自己写，有的编译器会提供额外的语法，如在函数声明时多加一个描述字符串‘__interrupt__’，则编译器碰到这样的函数时，就会自动加上存储/恢复寄存器的指令，并用‘interrup treturn’指令来返回中断发生点，这样就不用写这些细节了。
```
当产品规格定义完成以及硬件架构大致底定后，Driver API就可以开始进行设计了。我想在设计这套API时，应该要将重心放在系统式与应用程序的需求上；对于硬件设计，我们只需确认其确实能够达成这些API的功能，至于硬件电路的细节应该不会影响Driver API的设计.<br><br>
实际上我们会把.h文件和包含空函数的.c文件先写好，这样的好处是在驱动程序还没稳定之前，不会影响系统的编译，其他的程序都可以同步开发。如此一来，我们会接收到其他人员对Driver API的意见，有必要的话，也可以尽早修改设计。<br><br>
此外，***我们一般称Driver API为硬件抽象层（Hardware Abstract Level; HAL），它对嵌入式系统开发还有一项重要的意义。因为Driver API上层的程序都是和硬件无关的，所以负责模拟器的人员只要在PC上模拟出这些API的行为，其他上层的程序应该完全不需要任何更动，就可以在机器与模拟器上运行，这样的架构自然会让系统具备较佳的可移植性。***<br>

## 6. 设计硬件抽象层<br>

## 7. 菜鸟当自强：软件工程师硬起来<br>
第11章：菜鸟当自强：软件工程师硬起来■　
第12章：做好存储器管理■　
第13章：存储器管理（II）：NAND Flash概论■　
第14章：模拟器■　
附录B：Callback Function■　
附录C：用C来实作面向对象的概念