---
layout: post
title: "linux 文件/目录 权限管理"
date:   2022-5-25
tags: [linux]
comments: true
author: wsxk
---

讲到拿shell，提权，其实这些跟linux的权限管理是分不开的（笑，虽然我现在才开始了解。<br>
虽然对于普通用户来说，那么严格的权限划分是没有意义的（相信大家在使用linux系统时，大部分只用到了root和你自己创建的普通用户吧<br>

- [1. 用户和用户组](#1-用户和用户组)
    - [uid和gid](#uid和gid)
- [linux文件管理](#linux文件管理)
    - [rwx](#rwx)
  - [可执行文件管理](#可执行文件管理)
    - [特殊权限s](#特殊权限s)
- [特例root](#特例root)
- [linux 目录权限](#linux-目录权限)
    - [linux目录权限和目录下文件权限的冲突](#linux目录权限和目录下文件权限的冲突)
    - [粘滞位t](#粘滞位t)
  - [reference](#reference)

# 1. 用户和用户组<br>
Linux的多任务多用户操作系统，它支持同一时间不同用户在各自执行任务。<br>
在执行不同任务需要有不同的权限，这就有了用户的概念（每个人都是root，那可是灾难性后果）<br>
所以不同的用户有不同的权限。<br>
但是如果有一批人都要执行同样的任务，你一个个给每个用户赋予权限就有点麻烦，这就是用户组的诞生了。<br>
所谓用户组，就是把一群有一样权限的人归在一起。这样你要申请一个用户，就直接把它拉到相应的用户组里就行，不用你单独赋值管理。<br>
用户和用户组有以下关系<br>
用户和用户组的对应关系有以下 4 种：<br>

    一对一：一个用户可以存在一个组中，是组中的唯一成员；
    一对多：一个用户可以存在多个用户组中，此用户具有这多个组的共同权限；
    多对一：多个用户可以存在一个组中，这些用户具有和组相同的权限；
    多对多：多个用户可以存在多个组中，也就是以上 3 种关系的扩展。


### uid和gid

每个用户都有一个uid（标明自己身份的）和一个gid（表明它所属的组）

毕竟用户名和组名，其实说白了，是方便我们人来理解的，计算机可不认这个。

# linux文件管理

对于文件来说，使用它的人只有以下3种身份。

owner，group，other，即创建者，

除了所有者，所有者所在的组的其他成员，剩余用户访问文件都是other类别

### rwx

对于不同3种身份，正常情况下都有rwx来表示他们的权限

r为可读

w为可写

x为可执行

## 可执行文件管理

可执行文件执行时的权限，是按照你使用的用户来定的。（一般情况下，你是root执行这个程序，这个程序就有root权限，普通用户执行，就是普通用户权限，但是有特例）

可执行文件比较特殊，它相比正常文件（拥有uid和gid，这个是你执行的用户的uid和gid）外，多了

euid和egid（有效用户和有效group）

可执行文件在运行过程的实际权限是由euid和egid决定的。这跟特殊权限s有关。

### 特殊权限s

s权限和x权限是占据同一个位置的

仅针对可执行文件。此种权限通常称为 SetUID，简称 SUID 特殊权限。

SUID 特殊权限仅适用于可执行文件，所具有的功能是，只要用户对设有 SUID 的文件有执行权限，那么当用户执行此文件时，会以文件所有者的身份去执行此文件，一旦文件执行结束，身份的切换也随之消失（uid仍然是普通用户，但是euid为root）

换句话说，如果这个文件所有者是root，设置了suid，当你普通用户可以执行这个程序时，你运行这个程序获得的就是root权限。（注意，果是fork一个进程的话，因为完全复制进程的内容，所以也有root权限，指euid，egid，但是，执行system("/bin/sh")或者exec("/bin/sh")时是拿不到root shell的，
>Ubuntu 16.04以上版本，/bin/sh实际上是一个指向/bin/dash的链接文件，dash实现了 一个保护机制，当它发现自己在一个Set-UID的进程中运行时，会立刻把有效用户id变成实际 用户id，主动放弃特权。安装一个zsh的shell程序来做这个实验，再建个链接过去<br>
sudo apt install zsh<br>
sudo ln -sf /bin/zsh /bin/sh）

当程序结束时，这种角色切换消失。<br>
另外，如果你执行的程序运行了另一个程序（exec），并不会改变你的RUID,RGID，如果其他程序有+s位，会改变相应的euid，egid。

值得注意的是 如果你是以root的身份运行+s的属于普通用户的程序时，仍然是root权限。

# 特例root

正常情况下，其实只有文件的owner可以任意修改该文件的访问权限。但是也有例外

没错就是高贵的root！root是linux的超级管理员，想干啥就干啥，它可以对任何一个文件或目录进行修改。


# linux 目录权限

linux目录权限如下

    1 可执行权限(x): 如果目录没有可执行权限, 则无法cd到目录中。
    2 可读权限(r): 如果目录没有可读权限, 则无法用ls等命令查看目录中的文件内容。
    3 可写权限(w): 如果目录没有可写权限, 则无法在目录中创建文件, 也无法在目录中删除文件。

### linux目录权限和目录下文件权限的冲突

比如你是一个普通用户user。

abc是由root创建的任何用户都具有rwx权限的目录

abc目录下有一个文件 test.c test.c对普通用户是完全拒绝的，没有rwx。

此时你进入了abc目录下，执行删除命令

    rm test.c

你把它删掉了。凭什么？

    如果目录本身对others具有w权限，那么others可以删除掉任何目录下的文件。
    
    如果目录本身对others没有w权限，那么others则不可以删除文件。

### 粘滞位t

那当我们有这么一种需求，others可以在特定的目录下创建自己的文件、写入自己文件、删除自己的文件，但是不想让他删除别人的文件。这时后这么办呢？

这时可以对目录添加一个粘滞位：【chmod o+t 文件名】，这个粘滞位只能对目录设置。一般是限制others的权限。对于设置了粘滞位的目录。在该目录下。只能文件的拥有者或root可以删除，其他人不能删除。


    当一个目录被设置为"粘滞位"(用chmod +t),则该目录下的文件只能由
    一、超级管理员删除
    二、该目录的所有者删除
    三、该文件的所有者删除


## reference

[http://c.biancheng.net/view/3042.html](http://c.biancheng.net/view/3042.html)

[https://blog.csdn.net/weixin_64181464/article/details/123068250](https://blog.csdn.net/weixin_64181464/article/details/123068250)