---
layout: post
tags: [iot_dev]
date: 2023-8-13
author: wsxk
comments: true
title: "iot dev technology"
---

- [1. 第一个嵌入式系统](#1-第一个嵌入式系统)
  - [boot的作用](#boot的作用)
- [2. 实作嵌入式系统平台](#2-实作嵌入式系统平台)
- [3. 构建良好的嵌入式系统开发环境](#3-构建良好的嵌入式系统开发环境)


`PS: 更新于2023-10-04`<br>

## 1. 第一个嵌入式系统<br>
入门嵌入式系统开发，需要了解嵌入式开发和传统PC程序开发的差别和联系。<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2023-7-6/20230923211703.png)
从图中可以看出，虽然嵌入式开发和PC程序开发使用的工具基本上没有相似之处，但是开发流程和编写代码的基本思想都是类似的。<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2023-7-6/20230923211906.png)

在一个嵌入式系统按下电源键启动时，会发生如下的事情：<br>
```
Step01：CPU会到特定的地址获取第一行指令来执行（boot），实际的细节有两种。   
    1. CPU重新启动后，将其PC（Program Counter）寄存器设为特定地址，只要user的程序确实存储在这个地址，就可以正确被执行。
    2. CPU重新启动后，会将CPU中存储中断矢量表地址的寄存器设为某特定地址，接着引发‘RESET中断’，所以程序员只要把中断矢量表存储在这个地址，并指定‘Reset中断的处理程序’为自己写的某个函数（如：boot()），则该函数就可以在开机后被CPU执行

Step02：User程序开始运行后，会先对CPU做初始化的动作。

Step03：将程序的数据段从只读存储器（ROM或Flash）载入到RAM中。

Step04：CPU初始化完毕后，紧接着会初始化应用程序用到的硬设备。

Step05：初始化各个子系统，如嵌入式操作系统（RTOS）、动态存储器管理、图形界面系统等。

Step06：执行应用程序的主程序。
```
**所谓的中断矢量表就是从某个地址开始，每4个Byte为一个单位（entry），每一个entry记录一个函数的地址**<br>

### boot的作用<br>
上面提到的执行主程序之前的操作，都由boot一个函数来完成，boot其实就是嵌入式系统在进入主程序运行之前，运行的函数<br>
boot具体作如下几件事<br>
```
Step01：设定某些重要的CPU寄存器，特别是堆栈指针寄存器（Stack Pointer；简称SP）与状态寄存器（Status Register）(状态寄存器：在大部分的初始化动作还未完成之前，此时，若产生中断是很麻烦的事情。所以在boot阶段最重要的事就是命令CPU禁止中断产生，直到初始化动作都做完后，才把中断功能打开。CPU的状态寄存器由很多状态标志组成，通常都会包含用来设定CPU是否接受中断的标志。)

Step02：CPU各部分功能初始化。

Step03：系统初始化。

Step04：调用应用程序的主程序。

Step05：结束（通常应用程序的主程序不会返回boot程序）
```

## 2. 实作嵌入式系统平台<br>
如果对一个嵌入式系统进行分层，那么有如下几层:
```
Boot-Loader与驱动程序
OS与API
子系统与库函数
应用程序
```
对应图如下:
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2023-7-6/20230927000532.png)

嵌入式系统平台指的就是让电子产品的‘应用程序’得以顺利开发的环境，所以系统平台不只是软件或硬件的概念而已，它是一个稳定的环境。所以**嵌入式平台可以是boot-loader与驱动程序，OS与API，子系统与库函数的组合**<br>
但是上述的对应图只能描述更层级的关系，不能描述数据传输的过程，数据传输过程如下：<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2023-7-6/20230927221905.png)
计算机系统的原理不外乎处理输入事件，产生结果并输出，嵌入式系统也不例外，让我们从外围设备状态发生变化开始讲起.<br>
通常输入的来源有两个。一种是由`监督程序（Monitor）`持续主动地监督某个外围设备的状态是否改变（我们称这种方法为`Polling(轮询)`或`Busy Waiting`）；另一种则是由外围设备主动产生中断。不管是Polling或中断，基本上都是因为外围设备的状态产生变化，例如，使用者点触了触控式屏幕、或温度检测器发现异常温度等等。<br><br>
当某设备状态发生变化，相应的驱动程序会被执行。如果是Polling方式，则驱动程序是由监督程序所引发；若是中断的方式，则相应的中断处理程序（ISR）会被执行。<br><br>
ISR（以下就用中断方式来说明）只会马上判断硬件状态发生了什么变化，并且把新的状态往上层送（如哪个key被按下）。所谓的传送方式有很多，最简单的方式是设定某个全局变量，上层程序只要读取这个变量，就知道某个硬件事件发生了。如果硬件事件发生的很频繁，例如：网络的封包，只用一个全局变量传递信息，势必会遗失很多的硬件事件，此时就要用其它较复杂的方式，如message queue<br><br>
系统层会有一个无限循环，循环内的工作就是持续检查有没有新的硬件事件到达，若有则处理之；若无则系统可暂时进入idle mode。<br><br>
当硬件事件被系统处理完之后，系统会决定是否将其送给应用程序。同样的，系统程序与应用程序间有许多不同的沟通方式，例如，应用程序可以对其欲处理的硬件事件注册callback function，则当该事件发生时，系统自然会执行应用程序的事件处理函数<br><br>

**开发嵌入式操作系统时，最值得注意的是共享机制的设计，且调度算法应由应用程序为优先**<br>

## 3. 构建良好的嵌入式系统开发环境<br>
嵌入式系统开发环境包含以下几个方面`集成开发工具、 Cross compiler 、制作可执行文件的批处理文件（build.bat) 、makefile 、Link Script、 调试工具、下载工具、 其他工具（Offline Tools)、 模拟器、 版本控制工具`<br>
虽然对于绝大部分开发员工来说，没有必要熟悉开发环境的构建步骤，但是熟悉一下也没什么坏处不是嘛（<br>
`集成开发工具`没啥好说的，就是`IDE`,只不过嵌入式服务产商中，很多都有自己的开发环境IDE，很少用到像`Eclipse`这样的开源IDE<br>
`Cross compiler`指的是交叉编译工具集合，正常的编译器只能编译在本地机器上运行的程序，交叉编译器用于在本地机器上编译<br>

第8章：上电之后：Boot Loader■　
第9章：驱动程序■　
第10章：设计硬件抽象层■　
第11章：菜鸟当自强：软件工程师硬起来■　
第12章：做好存储器管理■　
第13章：存储器管理（II）：NAND Flash概论■　
第14章：模拟器■　
附录B：Callback Function■　
附录C：用C来实作面向对象的概念
