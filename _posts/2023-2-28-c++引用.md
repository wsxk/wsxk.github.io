---
layout: post
tags: [c++]
title: "c++引用&类"
date: 2023-2-28
author: wsxk
comments: true
---

- [引用](#引用)
- [类](#类)
  - [class和struct的区别](#class和struct的区别)
  - [如何使用类](#如何使用类)


## 引用<br>
c++的引用其实是一种`semantic sugar`。<br>
引用相当于给变量起一个别名。<br>
**因此，引用在声明时就必须有一个定义，并且这个定义在这个程序中无法被更改**<br>
```c++
int x = 6;
int b = 3;
std::cout << x << std::endl;
int& ref=x; //这个程序中，ref只能是x的别名
ref= b; //相当于 x = b
```
其实引用这种用法在普通编写代码时显得没有必要，但是在函数传参中就比较有用了。<br>
```c++
int increment(int& x) {
	x++;
	return 0;
}

int main() {
	int x = 6;
	int b = 3;
	std::cout << x << std::endl;
	int& ref=x;
	increment(x);

	std::cout << x << std::endl;	
}
```
用这种办法，相比于指针，使得代码清晰好看了不少（😀其实这就是引用的作用）<br>
**引用能做的，指针也能做；引用不能做的，指针也无法做到**<br>
**实际上引用的底层逻辑就是指针**<br>
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2023-2-18-reverse/20230228131703.png)
![](https://raw.githubusercontent.com/wsxk/wsxk_pictures/main/2023-2-18-reverse/20230228131733.png)


## 类<br>
类是面向对象编程的一种概念<br>
类是一种物体的宏观描述（data 加 function）<br>
```c
class player {
public:
	int x, y, speed;
	void move(int xa, int ya, int speeda) {
		x += xa * speeda;
		y += ya * speeda;
	}
};

int main() {
	player playerx, playery;
	playerx.x = 1;
	playerx.y = 1;
	playerx.speed = 2;
	playerx.move(2, 4, 5);
	std::cout << playerx.x<< std::endl;
}
```

### class和struct的区别<br>
其实唯一的区别是默认的可见性。<br>
**class默认私有（private），struct默认公开（public）**<br>
```c++
struct player {
	int x, y, speed;
	void move(int xa, int ya, int speeda) {
		x += xa * speeda;
		y += ya * speeda;
	}
};

int main() {
	player playerx, playery;
	playerx.x = 1;
	playerx.y = 1;
	playerx.speed = 2;
	playerx.move(2, 4, 5);
	std::cout << playerx.x<< std::endl;
}
```
这段代码跟上一段代码是同一个效果。<br>
虽然实际上`struct`和`class`在技术上没有区别，但是大多数人都对它们两个做了区分。<br>
> 1. struct用在少量的数据操作上，class用在比较复杂的行为上（比如玩家的属性，功能，etc）
> 2. 用在继承（inherit）上，普遍用法都是class


### 如何使用类<br>
```c++
#include <iostream>

class Log {
public:
	const int LogLevelError = 0;
	const int LogLevelWarning = 1;
	const int LogLevelInfo = 2;
private:
	int m_LogLevel;
public:
	void SetLogLevel(int level) {
		m_LogLevel = level;
	}
	void LogError(const char* message) {
		if (m_LogLevel >= LogLevelError) {
			std::cout << "[ERROR]: " << message << std::endl;
		}
	}
	void LogWarning(const char* message) {
		if (m_LogLevel >= LogLevelWarning) {
			std::cout << "[WARNING]: " << message << std::endl;
		}
	}
	void LogInfo(const char* message) {
		if (m_LogLevel >= LogLevelInfo) {
			std::cout << "[INFO]: " << message << std::endl;
		}
	}
};

int main() {
	Log log;
	log.SetLogLevel(log.LogLevelWarning);
	log.LogError("hello");
	log.LogWarning("hello");
	log.LogInfo("hello");
	
}
```