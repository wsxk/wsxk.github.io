---
layout: post
tags: [c++]
date: 2023-3-5
author: wsxk
title: "c++ 字符字面量 & const关键字"
comments: true
---

- [字符字面量](#字符字面量)
	- [番外](#番外)
- [const](#const)
	- [const用在class中的function](#const用在class中的function)


## 字符字面量<br>
出现形如
```c++
const char * name = "12345";
```
的东西，`"12345"`就说一个字符字面量，它会被存储在用户只读的访问区域内，因此形如
```c++
char * name = "12345";
name[2] = 'a';
```
是无效的，未定义的行为。<br>

### 番外<br>
顺道一提，其实c++的字符串中的每个字符可以是`1`,`2`,`4`个字节，如下图所示<br>
```c++
const char * name = u8"wsxk";//utf-8 1 byte
const char16_t * name1 = u"wsxk";//utf-16 2bytes
const char32_t * name2 = U"wsxk";//utf-32 4bytes
const wchar_t * name3 = L"wsxk";//由编译器认定，windows通常是2bytes，linux是4bytes
```
另外，可以用一个神秘字符，来增加代码可读性:
```c++
const char * name = R"(line1
line2
line3
line4)";

//等价
const char * name = "line1\n"
"line2\n"
"line3\n"
"linr4\n";
```


## const<br>
`const`只是一个语法上的承诺，你承诺这个变量是个常量，仅此而已<br>
const int *a 表示a指向的地址中的内容不能被修改，可以理解为我把指向内容的int类型声明为const不准修改了，因为const和int在一起<br>
int * const a 表示a指向的地址不能修改，可以理解为这个const和指针名在一起，表示a存储的值（指向的地址）不能改变。<br>

### const用在class中的function<br>
```c++
#include <iostream>

class Entity {
public:
	int x, y;
	int getX() const {
		return x;
	}
};
int main() {
	Entity e;
}
```
这种说明意味着 Entity类中的getX方法承诺不会修改类中的属性<br>

但是**如果你在调试的时候想用一下应该怎么办呢？**<br>
于是乎出现了`mutable`关键字。<br>
```c++
#include <iostream>

class Entity {
public:
	int x, y;
	mutable int m_Debugcount=0;
	int getX() const {
		m_Debugcount++;
		return x;
	}
};
int main() {
	Entity e;
	
}
```
这种用法是可行的。<br>